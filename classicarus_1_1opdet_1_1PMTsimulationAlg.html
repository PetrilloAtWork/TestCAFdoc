<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAF format: icarus::opdet::PMTsimulationAlg Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/TeX/AMSmath','[tex]/TeX/AMSsymbols']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','TeX/AMSmath','TeX/AMSsymbols']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CAF format<span id="projectnumber">&#160;${SBNANAOBJ_VERSION}</span>
   </div>
   <div id="projectbrief">Simulation, reconstruction and analysis software for the ICARUS experiment.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicarus.html">icarus</a></li><li class="navelem"><a class="el" href="namespaceicarus_1_1opdet.html">opdet</a></li><li class="navelem"><a class="el" href="classicarus_1_1opdet_1_1PMTsimulationAlg.html">PMTsimulationAlg</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classicarus_1_1opdet_1_1PMTsimulationAlg-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">icarus::opdet::PMTsimulationAlg Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Algorithm class for the full simulation of PMT channels.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html">ConfigurationParameters_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type holding all configuration parameters for this algorithm.  <a href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicarus_1_1opdet_1_1PMTsimulationAlg_1_1GainFluctuator.html">GainFluctuator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicarus_1_1opdet_1_1PMTsimulationAlg_1_1TimeToTickAndSubtickConverter.html">TimeToTickAndSubtickConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to convert tick point into a tick number and a subsample index.  <a href="classicarus_1_1opdet_1_1PMTsimulationAlg_1_1TimeToTickAndSubtickConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad0d1bbb07ed881250f460e9817bc9c50" id="r_ad0d1bbb07ed881250f460e9817bc9c50"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50">DiscriminationAlgo</a> { <a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50ac9f88e098f6fe4e4e112eeb05ccb9671">Unset</a>
, <a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50a362b9efdb814a78f5f14520be6ffe3de">AboveThreshold</a>
, <a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50a338847afd26d8b1527f2feaa0ad0f236">CrossingThreshold</a>
 }</td></tr>
<tr class="memdesc:ad0d1bbb07ed881250f460e9817bc9c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to discriminate the waveform to determine the readout regions.  <a href="#ad0d1bbb07ed881250f460e9817bc9c50">More...</a><br /></td></tr>
<tr class="separator:ad0d1bbb07ed881250f460e9817bc9c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a7cd37fa19e059995a83d4e36cdc35" id="r_aa1a7cd37fa19e059995a83d4e36cdc35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1a7cd37fa19e059995a83d4e36cdc35">microsecond</a> = util::quantities::microsecond</td></tr>
<tr class="separator:aa1a7cd37fa19e059995a83d4e36cdc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f39ff759ede48d42c9e0f2b8c8f1d3" id="r_a20f39ff759ede48d42c9e0f2b8c8f1d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20f39ff759ede48d42c9e0f2b8c8f1d3">nanosecond</a> = util::quantities::nanosecond</td></tr>
<tr class="separator:a20f39ff759ede48d42c9e0f2b8c8f1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba47fd61d026688fba53d5854013ad5" id="r_a0ba47fd61d026688fba53d5854013ad5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba47fd61d026688fba53d5854013ad5">hertz</a> = util::quantities::hertz</td></tr>
<tr class="separator:a0ba47fd61d026688fba53d5854013ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bab02ebb9a95fc0fe9733f2e545a2f" id="r_ab2bab02ebb9a95fc0fe9733f2e545a2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2bab02ebb9a95fc0fe9733f2e545a2f">megahertz</a> = util::quantities::megahertz</td></tr>
<tr class="separator:ab2bab02ebb9a95fc0fe9733f2e545a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c349abcd10ca7cb1cc63505b38f427" id="r_af1c349abcd10ca7cb1cc63505b38f427"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c349abcd10ca7cb1cc63505b38f427">picocoulomb</a> = util::quantities::picocoulomb</td></tr>
<tr class="separator:af1c349abcd10ca7cb1cc63505b38f427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17a9af8a4cec78a3381487ba80cec42" id="r_ac17a9af8a4cec78a3381487ba80cec42"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac17a9af8a4cec78a3381487ba80cec42">tick</a> = util::quantities::tick</td></tr>
<tr class="separator:ac17a9af8a4cec78a3381487ba80cec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e0cf8d4a2cb17d1646b87c43d93cdb" id="r_ad2e0cf8d4a2cb17d1646b87c43d93cdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2e0cf8d4a2cb17d1646b87c43d93cdb">ADCcount</a> = DiscretePhotoelectronPulse::ADCcount</td></tr>
<tr class="separator:ad2e0cf8d4a2cb17d1646b87c43d93cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5018b83f2da4426565f512d5972312dd" id="r_a5018b83f2da4426565f512d5972312dd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5018b83f2da4426565f512d5972312dd">time_interval</a> = detinfo::timescales::time_interval</td></tr>
<tr class="separator:a5018b83f2da4426565f512d5972312dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6c1f9995994044cb8527ba4c978fa4" id="r_a5c6c1f9995994044cb8527ba4c978fa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c6c1f9995994044cb8527ba4c978fa4">optical_tick</a> = detinfo::timescales::optical_tick</td></tr>
<tr class="separator:a5c6c1f9995994044cb8527ba4c978fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade12a71e902019f988d3f037226e1d8e" id="r_ade12a71e902019f988d3f037226e1d8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade12a71e902019f988d3f037226e1d8e">PMTsimulationAlg</a> (<a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html">ConfigurationParameters_t</a> const &amp;config)</td></tr>
<tr class="memdesc:ade12a71e902019f988d3f037226e1d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ade12a71e902019f988d3f037226e1d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575dfe444eb4a6f524203b4e0b3efd6f" id="r_a575dfe444eb4a6f524203b4e0b3efd6f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; raw::OpDetWaveform &gt;, std::optional&lt; sim::SimPhotons &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a575dfe444eb4a6f524203b4e0b3efd6f">simulate</a> (sim::SimPhotons const &amp;photons, sim::SimPhotonsLite const &amp;lite_photons)</td></tr>
<tr class="memdesc:a575dfe444eb4a6f524203b4e0b3efd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the waveforms originating from simulated photons.  <br /></td></tr>
<tr class="separator:a575dfe444eb4a6f524203b4e0b3efd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68f30e5e1cb4f4225fb3c8e00ab2ad" id="r_a1a68f30e5e1cb4f4225fb3c8e00ab2ad"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:a1a68f30e5e1cb4f4225fb3c8e00ab2ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a68f30e5e1cb4f4225fb3c8e00ab2ad">printConfiguration</a> (Stream &amp;&amp;out, std::string indent=&quot;&quot;) const</td></tr>
<tr class="memdesc:a1a68f30e5e1cb4f4225fb3c8e00ab2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the configuration into the specified output stream.  <br /></td></tr>
<tr class="separator:a1a68f30e5e1cb4f4225fb3c8e00ab2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8a9b679868bc55b87cfdfa539ef4f8b2" id="r_a8a9b679868bc55b87cfdfa539ef4f8b2"><td class="memItemLeft" align="right" valign="top">static util::MultipleChoiceSelection&lt; <a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50">DiscriminationAlgo</a> &gt; const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a9b679868bc55b87cfdfa539ef4f8b2">DiscrimAlgoSelector</a></td></tr>
<tr class="memdesc:a8a9b679868bc55b87cfdfa539ef4f8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the conversion between names and values of <code>DiscriminationAlgo</code>.  <br /></td></tr>
<tr class="separator:a8a9b679868bc55b87cfdfa539ef4f8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a483ae1c29f3c72dce79fe70a9bbd19d0" id="r_a483ae1c29f3c72dce79fe70a9bbd19d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a483ae1c29f3c72dce79fe70a9bbd19d0">OpDetWaveformMaker_t</a> = <a class="el" href="classicarus_1_1opdet_1_1OpDetWaveformMakerClass.html">icarus::opdet::OpDetWaveformMakerClass</a>&lt;ADCcount&gt;</td></tr>
<tr class="separator:a483ae1c29f3c72dce79fe70a9bbd19d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0367bc7919988b14cad97ed96ca83f1a" id="r_a0367bc7919988b14cad97ed96ca83f1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> = <a class="el" href="classicarus_1_1opdet_1_1OpDetWaveformMakerClass.html#a059010717ef64412260321512e9a0065">OpDetWaveformMaker_t::WaveformData_t</a></td></tr>
<tr class="memdesc:a0367bc7919988b14cad97ed96ca83f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type internally used for storing waveforms.  <br /></td></tr>
<tr class="separator:a0367bc7919988b14cad97ed96ca83f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa35080fd0e0cd56b63b9a8e444fda1" id="r_a7fa35080fd0e0cd56b63b9a8e444fda1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa35080fd0e0cd56b63b9a8e444fda1">WaveformValue_t</a> = <a class="el" href="quantities__utils_8h.html#aec2d6f44c4219db1eb1e84b12174228b">util::value_t</a>&lt;ADCcount&gt;</td></tr>
<tr class="memdesc:a7fa35080fd0e0cd56b63b9a8e444fda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric type in waveforms.  <br /></td></tr>
<tr class="separator:a7fa35080fd0e0cd56b63b9a8e444fda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954b0fdcf7649c843f9d268e39edd383" id="r_a954b0fdcf7649c843f9d268e39edd383"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a954b0fdcf7649c843f9d268e39edd383">PulseSampling_t</a> = <a class="el" href="classicarus_1_1opdet_1_1DiscretePhotoelectronPulse.html#a7d104b068a745bd0ecbc2c65fd6b84c9">DiscretePhotoelectronPulse::Subsample_t</a></td></tr>
<tr class="memdesc:a954b0fdcf7649c843f9d268e39edd383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of sampled pulse shape: sequence of samples, one per tick.  <br /></td></tr>
<tr class="separator:a954b0fdcf7649c843f9d268e39edd383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be1969083b04f9acf947b8f7c9abc3f" id="r_a5be1969083b04f9acf947b8f7c9abc3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5be1969083b04f9acf947b8f7c9abc3f">DiscriminationAlgoProc_t</a></td></tr>
<tr class="memdesc:a5be1969083b04f9acf947b8f7c9abc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of member function for zero-suppression discrimination.  <br /></td></tr>
<tr class="separator:a5be1969083b04f9acf947b8f7c9abc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3cc3a21bb1ea6096487ac723547db569" id="r_a3cc3a21bb1ea6096487ac723547db569"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cc3a21bb1ea6096487ac723547db569">makeGainFluctuator</a> () const</td></tr>
<tr class="memdesc:a3cc3a21bb1ea6096487ac723547db569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a configured gain fluctuator object.  <br /></td></tr>
<tr class="separator:a3cc3a21bb1ea6096487ac723547db569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c61f4ad6e9405a252cbab8e947eb6a" id="r_a71c61f4ad6e9405a252cbab8e947eb6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71c61f4ad6e9405a252cbab8e947eb6a">CreateFullWaveform</a> (sim::SimPhotons const &amp;photons, sim::SimPhotonsLite const &amp;lite_photons, std::optional&lt; sim::SimPhotons &gt; &amp;photons_used) const</td></tr>
<tr class="memdesc:a71c61f4ad6e9405a252cbab8e947eb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <code>raw::OpDetWaveform</code> objects from simulated photoelectrons.  <br /></td></tr>
<tr class="separator:a71c61f4ad6e9405a252cbab8e947eb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98d41ee81407f3146158f82091b4114" id="r_aa98d41ee81407f3146158f82091b4114"><td class="memItemLeft" align="right" valign="top">std::vector&lt; raw::OpDetWaveform &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa98d41ee81407f3146158f82091b4114">CreateFixedSizeOpDetWaveforms</a> (raw::Channel_t opChannel, <a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;waveform) const</td></tr>
<tr class="memdesc:aa98d41ee81407f3146158f82091b4114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <code>raw::OpDetWaveform</code> objects from a waveform data.  <br /></td></tr>
<tr class="separator:aa98d41ee81407f3146158f82091b4114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5aedae30146c923978d50b79972a974" id="r_ac5aedae30146c923978d50b79972a974"><td class="memTemplParams" colspan="2">template&lt;typename Combine &gt; </td></tr>
<tr class="memitem:ac5aedae30146c923978d50b79972a974"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5aedae30146c923978d50b79972a974">AddPulseShape</a> (<a class="el" href="#a954b0fdcf7649c843f9d268e39edd383">PulseSampling_t</a> const &amp;pulse, <a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;wave, tick const time_bin, Combine combination) const</td></tr>
<tr class="memdesc:ac5aedae30146c923978d50b79972a974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a pulse to a waveform, starting at a given tick.  <br /></td></tr>
<tr class="separator:ac5aedae30146c923978d50b79972a974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a2c07f8db979c4e848bf0264e96eee" id="r_a73a2c07f8db979c4e848bf0264e96eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73a2c07f8db979c4e848bf0264e96eee">AddPhotoelectrons</a> (<a class="el" href="#a954b0fdcf7649c843f9d268e39edd383">PulseSampling_t</a> const &amp;pulse, <a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;wave, tick const time_bin, <a class="el" href="#a7fa35080fd0e0cd56b63b9a8e444fda1">WaveformValue_t</a> const n) const</td></tr>
<tr class="memdesc:a73a2c07f8db979c4e848bf0264e96eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a number of pulses to a waveform, starting at a given tick.  <br /></td></tr>
<tr class="separator:a73a2c07f8db979c4e848bf0264e96eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4811a7ade9721915d9d37116b0dfaa65" id="r_a4811a7ade9721915d9d37116b0dfaa65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4811a7ade9721915d9d37116b0dfaa65">AddPedestal</a> (raw::Channel_t channel, std::uint64_t time, <a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;wave) const</td></tr>
<tr class="memdesc:a4811a7ade9721915d9d37116b0dfaa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the pedestal, including electronics noise.  <br /></td></tr>
<tr class="separator:a4811a7ade9721915d9d37116b0dfaa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3150d4ae20fbb7863b43898e2f4c9af1" id="r_a3150d4ae20fbb7863b43898e2f4c9af1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3150d4ae20fbb7863b43898e2f4c9af1">AddDarkNoise</a> (<a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;wave) const</td></tr>
<tr class="separator:a3150d4ae20fbb7863b43898e2f4c9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b45ac9161171d2e5be7957ce814e123" id="r_a6b45ac9161171d2e5be7957ce814e123"><td class="memItemLeft" align="right" valign="top">std::vector&lt; optical_tick &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123">FindTriggers</a> (<a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;wvfm, ADCcount baseline) const</td></tr>
<tr class="memdesc:a6b45ac9161171d2e5be7957ce814e123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns time points in <code>wvfm</code> where the readout should happen.  <br /></td></tr>
<tr class="separator:a6b45ac9161171d2e5be7957ce814e123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae984efaaf71aa4705fb02e3e4d2b77b2" id="r_ae984efaaf71aa4705fb02e3e4d2b77b2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; optical_tick &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae984efaaf71aa4705fb02e3e4d2b77b2">CreateTriggersCrossingThreshold</a> (<a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;wvfm, ADCcount baseline) const</td></tr>
<tr class="memdesc:ae984efaaf71aa4705fb02e3e4d2b77b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ticks in the specified waveform where some signal activity starts.  <br /></td></tr>
<tr class="separator:ae984efaaf71aa4705fb02e3e4d2b77b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93429bde5ff5468636441a14fe7756f5" id="r_a93429bde5ff5468636441a14fe7756f5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; optical_tick &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93429bde5ff5468636441a14fe7756f5">CreateTriggersAboveThreshold</a> (<a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;wvfm, ADCcount baseline) const</td></tr>
<tr class="memdesc:a93429bde5ff5468636441a14fe7756f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ticks in the specified waveform where some signal activity starts.  <br /></td></tr>
<tr class="separator:a93429bde5ff5468636441a14fe7756f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581771ca8bb008258a9edc794bc22944" id="r_a581771ca8bb008258a9edc794bc22944"><td class="memItemLeft" align="right" valign="top">std::vector&lt; optical_tick &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a581771ca8bb008258a9edc794bc22944">CreateBeamGateTriggers</a> () const</td></tr>
<tr class="memdesc:a581771ca8bb008258a9edc794bc22944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate periodic interest points regardless the actual activity.  <br /></td></tr>
<tr class="separator:a581771ca8bb008258a9edc794bc22944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cdd4eb7020b8dc92fcf7927fdc238e" id="r_a71cdd4eb7020b8dc92fcf7927fdc238e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71cdd4eb7020b8dc92fcf7927fdc238e">KicksPhotoelectron</a> () const</td></tr>
<tr class="memdesc:a71cdd4eb7020b8dc92fcf7927fdc238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random response whether a photon generates a photoelectron.  <br /></td></tr>
<tr class="separator:a71cdd4eb7020b8dc92fcf7927fdc238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0b180b9d817ac83770e99d4a7e2431" id="r_a7c0b180b9d817ac83770e99d4a7e2431"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ADCcount, ADCcount &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0b180b9d817ac83770e99d4a7e2431">saturationRange</a> (ADCcount baseline) const</td></tr>
<tr class="memdesc:a7c0b180b9d817ac83770e99d4a7e2431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADC range allowed for photoelectron saturation.  <br /></td></tr>
<tr class="separator:a7c0b180b9d817ac83770e99d4a7e2431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3139c49326f4d45f8186055f11ccfb" id="r_a0d3139c49326f4d45f8186055f11ccfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d3139c49326f4d45f8186055f11ccfb">ApplySaturation</a> (<a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;waveform, ADCcount baseline, std::pair&lt; ADCcount, ADCcount &gt; const &amp;range) const</td></tr>
<tr class="separator:a0d3139c49326f4d45f8186055f11ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64949072ec1786179761d3243a7f006d" id="r_a64949072ec1786179761d3243a7f006d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64949072ec1786179761d3243a7f006d">ApplySaturation</a> (<a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;waveform, ADCcount baseline) const</td></tr>
<tr class="memdesc:a64949072ec1786179761d3243a7f006d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the configured photoelectron saturation on the <code>waveform</code>.  <br /></td></tr>
<tr class="separator:a64949072ec1786179761d3243a7f006d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aae2e318ecd872a5882aa2c175b1fa1" id="r_a9aae2e318ecd872a5882aa2c175b1fa1"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aae2e318ecd872a5882aa2c175b1fa1">waveformStartTimestamp</a> () const</td></tr>
<tr class="memdesc:a9aae2e318ecd872a5882aa2c175b1fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timestamp matching the start of the full waveforms [UTC, ns].  <br /></td></tr>
<tr class="separator:a9aae2e318ecd872a5882aa2c175b1fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a691d908788045d83e9b9ea10f6e8edd3" id="r_a691d908788045d83e9b9ea10f6e8edd3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a691d908788045d83e9b9ea10f6e8edd3">ClipWaveform</a> (<a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;waveform, ADCcount min, ADCcount max)</td></tr>
<tr class="memdesc:a691d908788045d83e9b9ea10f6e8edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces <code>waveform</code> ADC within the <code>min</code> to <code>max</code> range (<code>max</code> included).  <br /></td></tr>
<tr class="separator:a691d908788045d83e9b9ea10f6e8edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dba9475e961de3dcc3581d4806cfccb" id="r_a3dba9475e961de3dcc3581d4806cfccb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a5be1969083b04f9acf947b8f7c9abc3f">DiscriminationAlgoProc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dba9475e961de3dcc3581d4806cfccb">selectDiscriminationAlgo</a> (<a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50">DiscriminationAlgo</a> algo)</td></tr>
<tr class="memdesc:a3dba9475e961de3dcc3581d4806cfccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the method corresponding to the specified algorithm enumerator.  <br /></td></tr>
<tr class="separator:a3dba9475e961de3dcc3581d4806cfccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1021a841e3d7a47a2ff8458c982675ae" id="r_a1021a841e3d7a47a2ff8458c982675ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html">ConfigurationParameters_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1021a841e3d7a47a2ff8458c982675ae">fParams</a></td></tr>
<tr class="memdesc:a1021a841e3d7a47a2ff8458c982675ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete algorithm configuration.  <br /></td></tr>
<tr class="separator:a1021a841e3d7a47a2ff8458c982675ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8992f7d6a13f5fa86f0e0a8a68f6b6b" id="r_af8992f7d6a13f5fa86f0e0a8a68f6b6b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8992f7d6a13f5fa86f0e0a8a68f6b6b">fQE</a></td></tr>
<tr class="memdesc:af8992f7d6a13f5fa86f0e0a8a68f6b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMT quantum efficiency.  <br /></td></tr>
<tr class="separator:af8992f7d6a13f5fa86f0e0a8a68f6b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065984ccb1859a6400c2d9f3262eb082" id="r_a065984ccb1859a6400c2d9f3262eb082"><td class="memItemLeft" align="right" valign="top">megahertz&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a065984ccb1859a6400c2d9f3262eb082">fSampling</a></td></tr>
<tr class="memdesc:a065984ccb1859a6400c2d9f3262eb082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wave sampling frequency [MHz].  <br /></td></tr>
<tr class="separator:a065984ccb1859a6400c2d9f3262eb082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9b79707c1b8f5afc175fdc8cd51eb0" id="r_abc9b79707c1b8f5afc175fdc8cd51eb0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc9b79707c1b8f5afc175fdc8cd51eb0">fNsamples</a></td></tr>
<tr class="memdesc:abc9b79707c1b8f5afc175fdc8cd51eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples per waveform.  <br /></td></tr>
<tr class="separator:abc9b79707c1b8f5afc175fdc8cd51eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa822578c863e4bdcac980b9186f33ec1" id="r_aa822578c863e4bdcac980b9186f33ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicarus_1_1opdet_1_1DiscretePhotoelectronPulse.html">DiscretePhotoelectronPulse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa822578c863e4bdcac980b9186f33ec1">wsp</a></td></tr>
<tr class="separator:aa822578c863e4bdcac980b9186f33ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264cc70d68ed62ae9fa8fcb38e7d3566" id="r_a264cc70d68ed62ae9fa8fcb38e7d3566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicarus_1_1opdet.html#a07cbeecef714f95f2165098fe548c471">PedestalGenerator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a264cc70d68ed62ae9fa8fcb38e7d3566">fPedestalGen</a> = nullptr</td></tr>
<tr class="memdesc:a264cc70d68ed62ae9fa8fcb38e7d3566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single photon pulse (sampled).  <br /></td></tr>
<tr class="separator:a264cc70d68ed62ae9fa8fcb38e7d3566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acede5ff0943f7e8d99481c005498631a" id="r_acede5ff0943f7e8d99481c005498631a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5be1969083b04f9acf947b8f7c9abc3f">DiscriminationAlgoProc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acede5ff0943f7e8d99481c005498631a">fDiscrAlgo</a> = nullptr</td></tr>
<tr class="memdesc:acede5ff0943f7e8d99481c005498631a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member function for the zero suppression discrimination algorithm.  <br /></td></tr>
<tr class="separator:acede5ff0943f7e8d99481c005498631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Algorithm class for the full simulation of PMT channels. </p>
<p>The algorithm creates simulated PMT waveforms as read out by ICARUS, including the generation of trigger primitives. Contributions to the waveforms include:</p><ul>
<li>physical photons</li>
<li>dark noise</li>
<li>electronics noise</li>
</ul>
<p>The algorithm processes an optical channel at a time, independently and uncorrelated from the other channels. For each channel, multiple waveforms may be generated according to the readout parameters.</p>
<h1>Activity sources </h1>
<h2>Physical photons </h2>
<p>Photons are read from <code>sim::SimPhotons</code> data objects, each one pertaining a single optical detector channel. Each photon on the channel is assumed to have successfully reached the external surface of the photocathode, with the wavelength shifter. Depending on the upstream simulation, and in particular on the photon visibility library settings, the photon might have also already passed the wavelength shifting and even triggered the conversion to a detectable photoelectron.</p>
<p>Quantum efficiency is simulated to determine if each photon converts into a photoelectron on the internal side of the photocathode. The target quantum efficiency is specified via the <code>QE</code> configuration parameter. It is assumed that some level of quantum efficiency has already been simulated upstream: more precisely, that the quantum efficiency already applied is in the amount returned by <code>detinfo::LArProperties::ScintPreScale()</code>. Therefore:</p>
<ol type="1">
<li>the quantum efficiency applied here is only the residual one to go from <code>detinfo::LArProperties::ScintPreScale()</code> to the value in <code>QE</code></li>
<li>there is no implement here to <em>increase</em> quantum efficiency, i.e. <code>QE</code> must not exceed <code>detinfo::LArProperties::ScintPreScale()</code></li>
<li>if the configuration specifies a target quantum efficiency <code>QE</code> larger than the one applied upstream (<code>detinfo::LArProperties::ScintPreScale()</code>), a warning message is printed, and no change to quantum efficiency is performed</li>
</ol>
<p>Note that if the upstream code has not applied any quantum efficiency, the configuration should give a <code>detinfo::LArProperties::ScintPreScale()</code> of 1.0.</p>
<dl class="section note"><dt>Note</dt><dd>If the photon visibility library already includes the probability of the photon converting to a photoelectron, the quantum efficiency check here should be skipped by setting the efficiency to 1.</dd></dl>
<p>For each converting photon, a photoelectron is added to the channel by placing a template waveform shape into the channel waveform.</p>
<p>The timestamp of each waveform is based on the same scale as the trigger time, as defined by <code>detinfo::DetectorClocks::TriggerTime()</code>. On that scale, the timestamp pins down the time of the first sample of the waveform. Note that this is typically earlier than when the actual signal starts. More precisely, the signal is defined to start at an interest point (see <code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code> for their definition), and the waveform starts (at tick #0) earlier than that by a fraction <code>PreTrigFraction</code> of the readout window size <code>ReadoutWindowSize</code> (both are configuration parameters of the algorithm), allowing for that amount of pre-trigger data.</p>
<p>The configuration parameter <code>TriggerOffsetPMT</code> describes how much earlier than the trigger time the optical readout has started. Note that if an interest point (see above) happens early after optical readout has started, there might be not enough data to fill the pre-trigger data. In such case, the interest point will just be located earlier than usual within the final waveform. This situation may be caused for example by asynchronous physics events like scintillation light from cosmic rays or radioactive decay of the detector materials, or from a fluctuation of the noise.</p>
<h2>Photoelectrons </h2>
<p>The response of the PMT to a single photoelectron is passed to the algorithm as a full blown function of type <code>SinglePhotonResponseFunc_t</code>. The function needs to be valid for the lifetime of the algorithm, since the algorithm refers to without owning it, and it is expected not to change during that time. See <code><a class="el" href="classicarus_1_1opdet_1_1SimPMTIcarus.html" title="Simulates the digitization of ICARUS PMT response and trigger.">icarus::opdet::SimPMTIcarus</a></code></p>
<p>To account for gain fluctuations, that shape is considered to correspond to a nominal gain (<code>PMTspecs.gain</code> configuration parameter), which is then fluctuated to obtain the effective gain. This feature can be disabled by setting configuration parameter <code>FluctuateGain</code> to <code>false</code>. The approximation used here is that the fluctuation is entirely due to the first stage of multiplication. The gain on the first stage is described as a random variable with Poisson distribution around the mean gain. The gain on a single photoelectron at the first stage is, in fact, an integral number in each case. The time spread of the signal may be increased by the difference in time of the different branches of the multiplication avalanche. Therefore, increasing or decreasing the number of branches, as it is done by changing the gain of the first stage, the time evolution of the signal will also be likewise affected. At this time we do not take this aspect into account in the simulation. For the nominal settings of a Hamamatsu 5912 photomultiplier (gain 10 ^7^, high multiplication on the first stage) the gain at the first stage is around 20, causing a fluctuation of about 20%. If the multiplication were equally distributed across the stages, that fluctuation would be almost 45%.</p>
<p>The first stage gain is computed by <code><a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t_1_1PMTspecs__t.html#abf3b0fcbc31969019bd5eb055dd38226" title="Returns the gain of the specified multiplication stage.">icarus::opdet::PMTsimulationAlg::ConfigurationParameters_t::PMTspecs_t::multiplicationStageGain()</a></code>.</p>
<h2>Dark noise </h2>
<p>Dark noise, i.e. the noise originating by "spontaneous" emission of a photoelectron in the photocathode without any external stimulation, is simulated by randomly extracting the time such emission happens. Each emission causes a photoelectron template waveform to be added at the extracted time. The rate of dark noise emission is set by configuration with <code>DarkNoiseRate</code> parameter.</p>
<h2>Electronics noise </h2>
<p>Electronics noise generation is delegated to an algorithm that also sets the waveform baseline and which can actually either add noise or transform the signal. Currently the "standard" noise model is Gaussian fluctuations of a given standard deviation, from tools <code><a class="el" href="structicarus_1_1opdet_1_1PMTgausNoiseGeneratorTool.html" title="Creates a icarus::opdet::GaussianNoiseGeneratorAlg algorithm.">PMTgausNoiseGeneratorTool</a></code> or <code><a class="el" href="structicarus_1_1opdet_1_1PMTfastGausNoiseGeneratorTool.html" title="Creates a icarus::opdet::FastGaussianNoiseGeneratorAlg algorithm.">PMTfastGausNoiseGeneratorTool</a></code>, with no noise correlation either in time or in space, while the standard pedestal model is a fixed value (<code><a class="el" href="structicarus_1_1opdet_1_1PMTconstantPedestalGeneratorTool.html" title="Creates a icarus::opdet::ConstantPedestalGeneratorAlg algorithm.">PMTconstantPedestalGeneratorTool</a></code>). Noise can be disabled by using the <code><a class="el" href="structicarus_1_1opdet_1_1PMTnoNoiseGeneratorTool.html" title="Creates a icarus::opdet::NoNoiseGeneratorAlg algorithm.">PMTnoNoiseGeneratorTool</a></code>.</p>
<h1>Configuration </h1>
<h2>PMT specifications </h2>
<p>PMT specifications are used to evaluate the variance of the gain. The details of the calculation are documented in <code><a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t_1_1PMTspecs__t.html#abf3b0fcbc31969019bd5eb055dd38226" title="Returns the gain of the specified multiplication stage.">icarus::opdet::PMTsimulationAlg::ConfigurationParameters_t::PMTspecs_t::multiplicationStageGain()</a></code>.</p>
<p>The available parameters include:</p>
<ul>
<li><code>gain</code> (default: <code>1e7</code>): the nominal gain of the PMT; this is just a reference value.</li>
<li><code>voltageDistribution</code> is a sequence of values, one for each stage of the multiplication chain of the PMT. Each number represents the relative size of the resistance that determines the fall of the potential on that stage. Only the stages that contribute to the gain need to be included. The absolute value of each element is inconsequential. For example, a 10-stage PMT with the first stage having twice the resistance of all the other would be represented by the setting <code>[ 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]</code>.</li>
<li><code>dynodeK</code> (default: <code>0.75</code>) represents the dependence of the gain of a stage on the potential drop: \( \mu_{i} \propto (\Delta V_{i})^{k} \) (with \( \mu_{i} \) the gain for stage \( i \), \( \Delta V_{i} \) the drop of potential of that stage and \( k \) the parameter set by <code>dynodeK</code>.</li>
<li><code>DiscrimAlgo</code> (choice, default: <code>"CrossingThreshold"</code>): selects one of the hard-coded discrimination algorithms used for zero suppression. The suppression algorithm identifies some interesting time points and issues a "trigger primitive" for each of them. A readout buffer is build around each trigger primitive (they are merged when overlapping). The algorithms currently supported are:<ul>
<li><code>CrossingThreshold</code>: a trigger primitive is issued whenever the signal passes from below threshold to above threshold. This algorithm suffers from a problem with large signals if the readout buffer is too short: the large signal may exceed the buffer while staying strictly above threshold and its tail will be lost until a fluctuation below and then back above threshold happens.</li>
<li><code>AboveThreshold</code>: a trigger primitive is issued on each sample above threshold, regardless the neighbours. No sample below threshold will be suppressed, and if the readout buffer is longer than the single photoelectron response (as it should) the tail of the buffer will always contain just noise.</li>
</ul>
</li>
</ul>
<h2>Random number generators </h2>
<p><a class="anchor" id="ICARUS_PMTSimulationAlg_RandomEngines"></a> Three independent random engines are currently used in the simulation:</p>
<ul>
<li>"main" random engine:<ul>
<li>residual quantum efficiency;</li>
<li>gain fluctuations;</li>
</ul>
</li>
<li>"dark noise" engine: dark current noise only;</li>
<li>"electronics noise" engine: electronics noise only.</li>
</ul>
<h1>Structure of the algorithm </h1>
<p><em>This section needs completion.</em></p>
<p>The algorithm is serviceable immediately after construction. Construction relies on a custom parameter data structure.</p>
<p>An utility, <code><a class="el" href="classicarus_1_1opdet_1_1PMTsimulationAlgMaker.html" title="Returns a new PMTsimulationAlg with an updated configuration.">PMTsimulationAlgMaker</a></code>, splits the set up in two parts:</p>
<ol type="1">
<li>configuration, where the full set of parameters is learned;</li>
<li>set up, where service providers, random number engines and the external single photon response function are acquired.</li>
</ol>
<p>This is supposed to make the creation of the filling of parameter structure and the creation of the algorithm easier. At that point, a single <code>sim::SimPhotons</code> can be processed (<code><a class="el" href="#a575dfe444eb4a6f524203b4e0b3efd6f" title="Returns the waveforms originating from simulated photons.">simulate()</a></code>) at a time, or multiple at the same time (see the multithreading notes below).</p>
<p>The function used to describe the single particle response is customizable and it must in fact be specified by the caller, since there is no default form. The function must implement the <code>PulseFunction_t</code> interface.</p>
<h2>Multithreading notes </h2>
<p>The algorithm processes one channel at a time, and it does not depend on event-level information; therefore, the same algorithm object can be used to process many events in sequence. On the other hand, multithreading is impaired by the random number generation, in the sense that multithreading will break reproducibility if the random engine is not magically thread-resistant.</p>
<p>If the set up is event-dependent, then this object can't be used for multiple events at the same time. There is no global state, so at least different instances of the algorithm can be run at the same time. In fact, the creation of an algorithm is expected to take negligible time compared to its run time on a single event, and it is conceivable to create a new algorithm instance for each event. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00371">371</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad2e0cf8d4a2cb17d1646b87c43d93cdb" name="ad2e0cf8d4a2cb17d1646b87c43d93cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e0cf8d4a2cb17d1646b87c43d93cdb">&#9670;&#160;</a></span>ADCcount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::ADCcount = DiscretePhotoelectronPulse::ADCcount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00380">380</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a5be1969083b04f9acf947b8f7c9abc3f" name="a5be1969083b04f9acf947b8f7c9abc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be1969083b04f9acf947b8f7c9abc3f">&#9670;&#160;</a></span>DiscriminationAlgoProc_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5be1969083b04f9acf947b8f7c9abc3f">icarus::opdet::PMTsimulationAlg::DiscriminationAlgoProc_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::vector&lt;optical_tick&gt; (<a class="code hl_function" href="#ade12a71e902019f988d3f037226e1d8e">PMTsimulationAlg</a>::*)</div>
<div class="line">      (<a class="code hl_typedef" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> <span class="keyword">const</span>&amp; wvfm, ADCcount baseline) const</div>
<div class="ttc" id="aclassicarus_1_1opdet_1_1PMTsimulationAlg_html_a0367bc7919988b14cad97ed96ca83f1a"><div class="ttname"><a href="#a0367bc7919988b14cad97ed96ca83f1a">icarus::opdet::PMTsimulationAlg::Waveform_t</a></div><div class="ttdeci">OpDetWaveformMaker_t::WaveformData_t Waveform_t</div><div class="ttdoc">Type internally used for storing waveforms.</div><div class="ttdef"><b>Definition</b> <a href="PMTsimulationAlg_8h_source.html#l00571">PMTsimulationAlg.h:571</a></div></div>
<div class="ttc" id="aclassicarus_1_1opdet_1_1PMTsimulationAlg_html_ade12a71e902019f988d3f037226e1d8e"><div class="ttname"><a href="#ade12a71e902019f988d3f037226e1d8e">icarus::opdet::PMTsimulationAlg::PMTsimulationAlg</a></div><div class="ttdeci">PMTsimulationAlg(ConfigurationParameters_t const &amp;config)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition</b> <a href="PMTsimulationAlg_8cxx_source.html#l00099">PMTsimulationAlg.cxx:100</a></div></div>
</div><!-- fragment -->
<p>Type of member function for zero-suppression discrimination. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00579">579</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a0ba47fd61d026688fba53d5854013ad5" name="a0ba47fd61d026688fba53d5854013ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba47fd61d026688fba53d5854013ad5">&#9670;&#160;</a></span>hertz</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::hertz = util::quantities::hertz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00376">376</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="ab2bab02ebb9a95fc0fe9733f2e545a2f" name="ab2bab02ebb9a95fc0fe9733f2e545a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bab02ebb9a95fc0fe9733f2e545a2f">&#9670;&#160;</a></span>megahertz</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::megahertz = util::quantities::megahertz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00377">377</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="aa1a7cd37fa19e059995a83d4e36cdc35" name="aa1a7cd37fa19e059995a83d4e36cdc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a7cd37fa19e059995a83d4e36cdc35">&#9670;&#160;</a></span>microsecond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::microsecond = util::quantities::microsecond</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00374">374</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a20f39ff759ede48d42c9e0f2b8c8f1d3" name="a20f39ff759ede48d42c9e0f2b8c8f1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f39ff759ede48d42c9e0f2b8c8f1d3">&#9670;&#160;</a></span>nanosecond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::nanosecond = util::quantities::nanosecond</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00375">375</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a483ae1c29f3c72dce79fe70a9bbd19d0" name="a483ae1c29f3c72dce79fe70a9bbd19d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483ae1c29f3c72dce79fe70a9bbd19d0">&#9670;&#160;</a></span>OpDetWaveformMaker_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classicarus_1_1opdet_1_1OpDetWaveformMakerClass.html">icarus::opdet::PMTsimulationAlg::OpDetWaveformMaker_t</a> = <a class="el" href="classicarus_1_1opdet_1_1OpDetWaveformMakerClass.html">icarus::opdet::OpDetWaveformMakerClass</a>&lt;ADCcount&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00568">568</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a5c6c1f9995994044cb8527ba4c978fa4" name="a5c6c1f9995994044cb8527ba4c978fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6c1f9995994044cb8527ba4c978fa4">&#9670;&#160;</a></span>optical_tick</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::optical_tick = detinfo::timescales::optical_tick</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00383">383</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="af1c349abcd10ca7cb1cc63505b38f427" name="af1c349abcd10ca7cb1cc63505b38f427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c349abcd10ca7cb1cc63505b38f427">&#9670;&#160;</a></span>picocoulomb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::picocoulomb = util::quantities::picocoulomb</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00378">378</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a954b0fdcf7649c843f9d268e39edd383" name="a954b0fdcf7649c843f9d268e39edd383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954b0fdcf7649c843f9d268e39edd383">&#9670;&#160;</a></span>PulseSampling_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a954b0fdcf7649c843f9d268e39edd383">icarus::opdet::PMTsimulationAlg::PulseSampling_t</a> = <a class="el" href="classicarus_1_1opdet_1_1DiscretePhotoelectronPulse.html#a7d104b068a745bd0ecbc2c65fd6b84c9">DiscretePhotoelectronPulse::Subsample_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of sampled pulse shape: sequence of samples, one per tick. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00576">576</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="ac17a9af8a4cec78a3381487ba80cec42" name="ac17a9af8a4cec78a3381487ba80cec42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17a9af8a4cec78a3381487ba80cec42">&#9670;&#160;</a></span>tick</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::tick = util::quantities::tick</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00379">379</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a5018b83f2da4426565f512d5972312dd" name="a5018b83f2da4426565f512d5972312dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5018b83f2da4426565f512d5972312dd">&#9670;&#160;</a></span>time_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using icarus::opdet::PMTsimulationAlg::time_interval = detinfo::timescales::time_interval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00382">382</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a0367bc7919988b14cad97ed96ca83f1a" name="a0367bc7919988b14cad97ed96ca83f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0367bc7919988b14cad97ed96ca83f1a">&#9670;&#160;</a></span>Waveform_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">icarus::opdet::PMTsimulationAlg::Waveform_t</a> = <a class="el" href="classicarus_1_1opdet_1_1OpDetWaveformMakerClass.html#a059010717ef64412260321512e9a0065">OpDetWaveformMaker_t::WaveformData_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type internally used for storing waveforms. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00571">571</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a7fa35080fd0e0cd56b63b9a8e444fda1" name="a7fa35080fd0e0cd56b63b9a8e444fda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa35080fd0e0cd56b63b9a8e444fda1">&#9670;&#160;</a></span>WaveformValue_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7fa35080fd0e0cd56b63b9a8e444fda1">icarus::opdet::PMTsimulationAlg::WaveformValue_t</a> = <a class="el" href="quantities__utils_8h.html#aec2d6f44c4219db1eb1e84b12174228b">util::value_t</a>&lt;ADCcount&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Numeric type in waveforms. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00573">573</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad0d1bbb07ed881250f460e9817bc9c50" name="ad0d1bbb07ed881250f460e9817bc9c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d1bbb07ed881250f460e9817bc9c50">&#9670;&#160;</a></span>DiscriminationAlgo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50">icarus::opdet::PMTsimulationAlg::DiscriminationAlgo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to discriminate the waveform to determine the readout regions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad0d1bbb07ed881250f460e9817bc9c50ac9f88e098f6fe4e4e112eeb05ccb9671" name="ad0d1bbb07ed881250f460e9817bc9c50ac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"><p>Mode not set. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad0d1bbb07ed881250f460e9817bc9c50a362b9efdb814a78f5f14520be6ffe3de" name="ad0d1bbb07ed881250f460e9817bc9c50a362b9efdb814a78f5f14520be6ffe3de"></a>AboveThreshold&#160;</td><td class="fielddoc"><p>Readout triggered when signal is above threshold. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad0d1bbb07ed881250f460e9817bc9c50a338847afd26d8b1527f2feaa0ad0f236" name="ad0d1bbb07ed881250f460e9817bc9c50a338847afd26d8b1527f2feaa0ad0f236"></a>CrossingThreshold&#160;</td><td class="fielddoc"><p>Readout triggered when signal crosses threshold. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00386">386</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade12a71e902019f988d3f037226e1d8e" name="ade12a71e902019f988d3f037226e1d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade12a71e902019f988d3f037226e1d8e">&#9670;&#160;</a></span>PMTsimulationAlg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icarus::opdet::PMTsimulationAlg::PMTsimulationAlg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html">ConfigurationParameters_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00099">99</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

<p class="reference">References <a class="el" href="classicarus_1_1opdet_1_1DiscretePhotoelectronPulse.html#ae915b7e8faad3f924c584e6f70177ddb">icarus::opdet::DiscretePhotoelectronPulse::checkRange()</a>, <a class="el" href="#acede5ff0943f7e8d99481c005498631a">fDiscrAlgo</a>, <a class="el" href="#a1021a841e3d7a47a2ff8458c982675ae">fParams</a>, <a class="el" href="#af8992f7d6a13f5fa86f0e0a8a68f6b6b">fQE</a>, <a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html#a722a428a96b4aeb957f5bcde1e5941bf">icarus::opdet::PMTsimulationAlg::ConfigurationParameters_t::larProp</a>, and <a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html#a8e0a1bfaac3a8395d52641aff56918b3">icarus::opdet::PMTsimulationAlg::ConfigurationParameters_t::QEbase</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3150d4ae20fbb7863b43898e2f4c9af1" name="a3150d4ae20fbb7863b43898e2f4c9af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3150d4ae20fbb7863b43898e2f4c9af1">&#9670;&#160;</a></span>AddDarkNoise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::AddDarkNoise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>wave</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00653">653</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a4811a7ade9721915d9d37116b0dfaa65" name="a4811a7ade9721915d9d37116b0dfaa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4811a7ade9721915d9d37116b0dfaa65">&#9670;&#160;</a></span>AddPedestal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::AddPedestal </td>
          <td>(</td>
          <td class="paramtype">raw::Channel_t</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>wave</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the pedestal, including electronics noise. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00644">644</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a73a2c07f8db979c4e848bf0264e96eee" name="a73a2c07f8db979c4e848bf0264e96eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a2c07f8db979c4e848bf0264e96eee">&#9670;&#160;</a></span>AddPhotoelectrons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::AddPhotoelectrons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a954b0fdcf7649c843f9d268e39edd383">PulseSampling_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>pulse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>wave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tick const</td>          <td class="paramname"><span class="paramname"><em>time_bin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7fa35080fd0e0cd56b63b9a8e444fda1">WaveformValue_t</a> const</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a number of pulses to a waveform, starting at a given tick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pulse</td><td>the sampling to add, scaled, to the waveform </td></tr>
    <tr><td class="paramname">wave</td><td>the waveform the pulses will be added to </td></tr>
    <tr><td class="paramname">time_bin</td><td>the tick of the waveform where the pulses start being added </td></tr>
    <tr><td class="paramname">n</td><td>the number of pulses added (it may be fractional)</td></tr>
  </table>
  </dd>
</dl>
<p>All the samples of <code>pulse</code> are scaled by the factor <code>n</code> and then <em>added</em> to the sampling waveform <code>wave</code>, starting from the <code>time_bin</code> sample of this waveform.</p>
<p>The <code>pulse</code> samples are a sequence of ADC counts describing the single photoelectron pulse shape. The waveform is also a sequence of samples representing a optical detector channel digitized waveform, starting at tick #0. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00603">603</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="ac5aedae30146c923978d50b79972a974" name="ac5aedae30146c923978d50b79972a974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5aedae30146c923978d50b79972a974">&#9670;&#160;</a></span>AddPulseShape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Combine &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::AddPulseShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a954b0fdcf7649c843f9d268e39edd383">PulseSampling_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>pulse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>wave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tick const</td>          <td class="paramname"><span class="paramname"><em>time_bin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combine</td>          <td class="paramname"><span class="paramname"><em>combination</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a pulse to a waveform, starting at a given tick. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Combine</td><td>binary operation combining two ADC counts into one </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pulse</td><td>the sampling to add to the waveform </td></tr>
    <tr><td class="paramname">wave</td><td>the waveform the pulse will be added to </td></tr>
    <tr><td class="paramname">time_bin</td><td>the tick of the waveform where the pulse starts </td></tr>
    <tr><td class="paramname">combination</td><td>how to combine the pulse and the waveform</td></tr>
  </table>
  </dd>
</dl>
<p>This is the internal implementation of <code><a class="el" href="#a73a2c07f8db979c4e848bf0264e96eee" title="Adds a number of pulses to a waveform, starting at a given tick.">AddPhotoelectrons()</a></code>.</p>
<p>The <code>combination</code> functor behaves as a binary function taking the existing <code>wave</code> sample and the sample from the <code>pulse</code> at the same time and returning their combination as a new sample value. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00624">624</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a64949072ec1786179761d3243a7f006d" name="a64949072ec1786179761d3243a7f006d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64949072ec1786179761d3243a7f006d">&#9670;&#160;</a></span>ApplySaturation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::ApplySaturation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>waveform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>baseline</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the configured photoelectron saturation on the <code>waveform</code>. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00725">725</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a0d3139c49326f4d45f8186055f11ccfb" name="a0d3139c49326f4d45f8186055f11ccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3139c49326f4d45f8186055f11ccfb">&#9670;&#160;</a></span>ApplySaturation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::ApplySaturation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>waveform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>baseline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; ADCcount, ADCcount &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies the configured photoelectron saturation on the <code>waveform</code>, only if the saturation is cutting into the digitisation <code>range</code>. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00738">738</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a691d908788045d83e9b9ea10f6e8edd3" name="a691d908788045d83e9b9ea10f6e8edd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691d908788045d83e9b9ea10f6e8edd3">&#9670;&#160;</a></span>ClipWaveform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::ClipWaveform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>waveform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces <code>waveform</code> ADC within the <code>min</code> to <code>max</code> range (<code>max</code> included). </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00758">758</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a581771ca8bb008258a9edc794bc22944" name="a581771ca8bb008258a9edc794bc22944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581771ca8bb008258a9edc794bc22944">&#9670;&#160;</a></span>CreateBeamGateTriggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::CreateBeamGateTriggers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate periodic interest points regardless the actual activity. </p>
<dl class="section return"><dt>Returns</dt><dd>a collection of ticks where we pretend interesting activity to be </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code></dd></dl>
<p>This methods emits a list of interest points according to the algorithm configuration. More precisely, if <code>CreateBeamGateTriggers</code> is configured <code>true</code>, <code>BeamGateTriggerNReps</code> interest points are generated at <code>BeamGateTriggerRepPeriod</code> intervals, starting from the beam gate time as defined by <code>detinfo::DetectorClocks::BeamGateTime()</code>.</p>
<p>See <code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code> for the meaning of "interest point".</p>
<dl class="section note"><dt>Note</dt><dd>It is assumed that tick <code>0</code> happens at a time defined by <code>triggerOffsetPMT</code> configuration parameter <em>after</em> the trigger (but since the value of that parameter is expected to be negative, tick <code>0</code> effectively happens <em>before</em> the trigger). </dd></dl>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00346">346</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="aa98d41ee81407f3146158f82091b4114" name="aa98d41ee81407f3146158f82091b4114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98d41ee81407f3146158f82091b4114">&#9670;&#160;</a></span>CreateFixedSizeOpDetWaveforms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; raw::OpDetWaveform &gt; icarus::opdet::PMTsimulationAlg::CreateFixedSizeOpDetWaveforms </td>
          <td>(</td>
          <td class="paramtype">raw::Channel_t</td>          <td class="paramname"><span class="paramname"><em>opChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>waveform</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <code>raw::OpDetWaveform</code> objects from a waveform data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opChannel</td><td>number of optical detector channel the data belongs to </td></tr>
    <tr><td class="paramname">waveform</td><td>the waveform data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection of <code>raw::OpDetWaveform</code></dd></dl>
<p>The waveform data is a sequence of samples on the optical detector channel, starting at the beginning of the optical time clock, that is set by the algorithm configuration as the global hardware trigger time (configured in <code>detinfo::DetectorClocks</code>) and an offset. It may be obtained from <code><a class="el" href="#a71c61f4ad6e9405a252cbab8e947eb6a" title="Creates raw::OpDetWaveform objects from simulated photoelectrons.">CreateFullWaveform()</a></code>.</p>
<p>Multiple waveforms may be returned for a single channel, since a form of zero suppression is applied by the simulated hardware. The waveforms are guaranteed to be non-overlapping, non-contiguous and sorted with increasing timestamp.</p>
<p>The procedure attempts to mimic the working mode of CAEN V1730B boards as described on page 32 of the manual "UM2792_V1730_V1725_rev2.pdf" in SBN DocDB 15024.</p>
<h2>Algorithm details </h2>
<p>In the board readout language, the "trigger" is the per-channel information that the signal on the channel has passed the threshold.</p>
<p>It is critical to understand the details of the generation of the triggers. At the time of writing, the algorithm in <code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code> emits a trigger every time the signal passes from under threshold to beyond threshold. Assuming that the threshold is at less than one photoelectron, this kind of behavior implies that every scintillation photons arriving on the tail of the first (large?) signal will add a new waveform in tail. It is not clear what happens if <em>two</em> more triggers happen while the window from the first trigger is still open.</p>
<p>The assumptions in the code include:</p>
<ol type="1">
<li>overlapped triggers are not discarded (p. 32);</li>
<li>board is set for self-trigger (p. 38);</li>
<li>each waveform has a fixed duration (except the ones overlapping the previous one);</li>
<li>when a trigger starts the recording window on a channel, only the last trigger happening during that window ("overlapping"), if any, is kept.</li>
<li>at decoding time, contiguous buffers are merged in a single waveform</li>
</ol>
<p>The fixed duration of the waveform if the sum of pre- and post-trigger window length. If during this window another trigger is emitted, a new window will follow the current one and it will be long enough to contain all the post-trigger data. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00493">493</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a71c61f4ad6e9405a252cbab8e947eb6a" name="a71c61f4ad6e9405a252cbab8e947eb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c61f4ad6e9405a252cbab8e947eb6a">&#9670;&#160;</a></span>CreateFullWaveform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::CreateFullWaveform </td>
          <td>(</td>
          <td class="paramtype">sim::SimPhotons const &amp;</td>          <td class="paramname"><span class="paramname"><em>photons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sim::SimPhotonsLite const &amp;</td>          <td class="paramname"><span class="paramname"><em>lite_photons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; sim::SimPhotons &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>photons_used</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <code>raw::OpDetWaveform</code> objects from simulated photoelectrons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">photons</td><td>the simulated list of photoelectrons </td></tr>
    <tr><td class="paramname">photons_used</td><td>(<em>output</em>) list of used photoelectrons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection of digitised <code>raw::OpDetWaveform</code> objects</dd></dl>
<p>This function performs the digitization of a optical detector channel which is collecting the photoelectrons in the <code>photons</code> list.</p>
<p>The photoelectrons are already screened for quantum efficiency: all of them are considered for use. It is still possible, if a reduction of the quantum efficiency is requested, that some of them are discarded.</p>
<p>The <code>photons_used</code> output argument is constructed and filled only if the configuration of the algorithm requires the creation of a list of used photons. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00185">185</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a93429bde5ff5468636441a14fe7756f5" name="a93429bde5ff5468636441a14fe7756f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93429bde5ff5468636441a14fe7756f5">&#9670;&#160;</a></span>CreateTriggersAboveThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::CreateTriggersAboveThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>wvfm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>baseline</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ticks in the specified waveform where some signal activity starts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wvfm</td><td>the waveform to parse </td></tr>
    <tr><td class="paramname">ADCcount</td><td>the value of the reference baseline </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection of ticks with interesting activity, sorted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code>, <code><a class="el" href="#ae984efaaf71aa4705fb02e3e4d2b77b2" title="Ticks in the specified waveform where some signal activity starts.">CreateTriggersCrossingThreshold()</a></code></dd></dl>
<p>This is an implementation of the algorithm for <code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code>.</p>
<p>An interest point is created whenever the signal is above a set threshold (configuration parameter <code>ThresholdADC</code>). Instead of issuing a trigger for every sample above the threshold, triggers are issued no more often than a readout post-trigger buffer as configured. This is just a computing optimization that should have no visible effect as long as each trigger is represented by a full readout window in the final waveform.</p>
<p>Compared to the <code><a class="el" href="#ae984efaaf71aa4705fb02e3e4d2b77b2" title="Ticks in the specified waveform where some signal activity starts.">CreateTriggersCrossingThreshold()</a></code>, this algorithm does not suffer from the effect of truncating strong signals but it will produce potentially more waveforms. If the threshold is lower than a single photoelectron, though, the main effect will only be potentially longer waveforms. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00430">430</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a3dba9475e961de3dcc3581d4806cfccb">selectDiscriminationAlgo()</a>.</p>

</div>
</div>
<a id="ae984efaaf71aa4705fb02e3e4d2b77b2" name="ae984efaaf71aa4705fb02e3e4d2b77b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae984efaaf71aa4705fb02e3e4d2b77b2">&#9670;&#160;</a></span>CreateTriggersCrossingThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::CreateTriggersCrossingThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>wvfm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>baseline</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ticks in the specified waveform where some signal activity starts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wvfm</td><td>the waveform to parse </td></tr>
    <tr><td class="paramname">ADCcount</td><td>the value of the reference baseline </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection of ticks with interesting activity, sorted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code>, <code><a class="el" href="#a93429bde5ff5468636441a14fe7756f5" title="Ticks in the specified waveform where some signal activity starts.">CreateTriggersAboveThreshold()</a></code></dd></dl>
<p>This is an implementation of the algorithm for <code><a class="el" href="#a6b45ac9161171d2e5be7957ce814e123" title="Returns time points in wvfm where the readout should happen.">FindTriggers()</a></code>.</p>
<p>An interest point is created whenever the signal passes from below the set threshold (configuration parameter <code>ThresholdADC</code>) to above it. This is also similar to how the CAEN 1730B readout board discrimination works, although this algorithm is by no mean sufficient to correctly emulate the work of that readout board, and the thresholds are better be left low so that a second-step readout simulation can take place afterwards.</p>
<p>Note that this algorithm can artificially truncate a strong signal which stays above threshold long time after having crossed it: in that case, only a trigger at the crossing point is issued, and if the signal is longer than the set readout window, truncation will occur. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00399">399</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a3dba9475e961de3dcc3581d4806cfccb">selectDiscriminationAlgo()</a>.</p>

</div>
</div>
<a id="a6b45ac9161171d2e5be7957ce814e123" name="a6b45ac9161171d2e5be7957ce814e123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b45ac9161171d2e5be7957ce814e123">&#9670;&#160;</a></span>FindTriggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::FindTriggers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0367bc7919988b14cad97ed96ca83f1a">Waveform_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>wvfm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>baseline</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns time points in <code>wvfm</code> where the readout should happen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wvfm</td><td>the waveform to parse </td></tr>
    <tr><td class="paramname">ADCcount</td><td>the value of the reference baseline </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection of ticks with interesting activity, sorted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a581771ca8bb008258a9edc794bc22944" title="Generate periodic interest points regardless the actual activity.">CreateBeamGateTriggers()</a></code>, <code><a class="el" href="#ae984efaaf71aa4705fb02e3e4d2b77b2" title="Ticks in the specified waveform where some signal activity starts.">CreateTriggersCrossingThreshold()</a></code>, <code><a class="el" href="#a93429bde5ff5468636441a14fe7756f5" title="Ticks in the specified waveform where some signal activity starts.">CreateTriggersAboveThreshold()</a></code></dd></dl>
<p>This method is a portal to enable the actual functions performing the task.</p>
<p>We define an "interest point" a time when some activity in the waveform is considered interesting enough to be recorded. This method returns a list of interest points, in the form of the index they are located at in the waveform <code>wvfm</code>.</p>
<p>These interest points are local readout triggers that drive zero suppression on the optical readout channel and that are not necessarily causing any level of event trigger.</p>
<p>Currently only two algorithms are set for this task: <code><a class="el" href="#ae984efaaf71aa4705fb02e3e4d2b77b2" title="Ticks in the specified waveform where some signal activity starts.">CreateTriggersCrossingThreshold()</a></code>, which has been the algorithm of choice since the beginning, and <code><a class="el" href="#a93429bde5ff5468636441a14fe7756f5" title="Ticks in the specified waveform where some signal activity starts.">CreateTriggersAboveThreshold()</a></code>.</p>
<p>This method also adds the mandatory beam gate interest points as explained in <code><a class="el" href="#a581771ca8bb008258a9edc794bc22944" title="Generate periodic interest points regardless the actual activity.">CreateBeamGateTriggers()</a></code> documentation. These are additional interest points that are added independently of whether there is actual interesting activity in there. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00373">373</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a71cdd4eb7020b8dc92fcf7927fdc238e" name="a71cdd4eb7020b8dc92fcf7927fdc238e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cdd4eb7020b8dc92fcf7927fdc238e">&#9670;&#160;</a></span>KicksPhotoelectron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::opdet::PMTsimulationAlg::KicksPhotoelectron </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random response whether a photon generates a photoelectron. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00598">598</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a3cc3a21bb1ea6096487ac723547db569" name="a3cc3a21bb1ea6096487ac723547db569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc3a21bb1ea6096487ac723547db569">&#9670;&#160;</a></span>makeGainFluctuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::makeGainFluctuator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a configured gain fluctuator object. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00170">170</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a1a68f30e5e1cb4f4225fb3c8e00ab2ad" name="a1a68f30e5e1cb4f4225fb3c8e00ab2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68f30e5e1cb4f4225fb3c8e00ab2ad">&#9670;&#160;</a></span>printConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void icarus::opdet::PMTsimulationAlg::printConfiguration </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>indent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the configuration into the specified output stream. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l01182">1182</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a7c0b180b9d817ac83770e99d4a7e2431" name="a7c0b180b9d817ac83770e99d4a7e2431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0b180b9d817ac83770e99d4a7e2431">&#9670;&#160;</a></span>saturationRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::saturationRange </td>
          <td>(</td>
          <td class="paramtype">ADCcount</td>          <td class="paramname"><span class="paramname"><em>baseline</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ADC range allowed for photoelectron saturation. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00711">711</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a3dba9475e961de3dcc3581d4806cfccb" name="a3dba9475e961de3dcc3581d4806cfccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dba9475e961de3dcc3581d4806cfccb">&#9670;&#160;</a></span>selectDiscriminationAlgo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::opdet::PMTsimulationAlg::selectDiscriminationAlgo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50">DiscriminationAlgo</a></td>          <td class="paramname"><span class="paramname"><em>algo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the method corresponding to the specified algorithm enumerator. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00800">800</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

<p class="reference">References <a class="el" href="#a93429bde5ff5468636441a14fe7756f5">CreateTriggersAboveThreshold()</a>, and <a class="el" href="#ae984efaaf71aa4705fb02e3e4d2b77b2">CreateTriggersCrossingThreshold()</a>.</p>

</div>
</div>
<a id="a575dfe444eb4a6f524203b4e0b3efd6f" name="a575dfe444eb4a6f524203b4e0b3efd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575dfe444eb4a6f524203b4e0b3efd6f">&#9670;&#160;</a></span>simulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; raw::OpDetWaveform &gt;, std::optional&lt; sim::SimPhotons &gt; &gt; icarus::opdet::PMTsimulationAlg::simulate </td>
          <td>(</td>
          <td class="paramtype">sim::SimPhotons const &amp;</td>          <td class="paramname"><span class="paramname"><em>photons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sim::SimPhotonsLite const &amp;</td>          <td class="paramname"><span class="paramname"><em>lite_photons</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the waveforms originating from simulated photons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">photons</td><td>all the photons simulated to land on the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of optical waveforms, response to those photons, and which photons were used (if requested)</dd></dl>
<p>Due to threshold readout, a single channel may result in multiple waveforms, which are all on the same channel but disjunct in time.</p>
<p>The second element of the return value is optional and filled only if the <code>trackSelectedPhotons</code> configuration parameter is set to <code>true</code>. In that case, the returned <code>sim::SimPhotons</code> contains a copy of each of the <code>photons</code> contributing to any of the waveforms. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00154">154</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<a id="a9aae2e318ecd872a5882aa2c175b1fa1" name="a9aae2e318ecd872a5882aa2c175b1fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aae2e318ecd872a5882aa2c175b1fa1">&#9670;&#160;</a></span>waveformStartTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t icarus::opdet::PMTsimulationAlg::waveformStartTimestamp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the timestamp matching the start of the full waveforms [UTC, ns]. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8cxx_source.html#l00780">780</a> of file <a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8a9b679868bc55b87cfdfa539ef4f8b2" name="a8a9b679868bc55b87cfdfa539ef4f8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9b679868bc55b87cfdfa539ef4f8b2">&#9670;&#160;</a></span>DiscrimAlgoSelector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">util::MultipleChoiceSelection&lt; <a class="el" href="#ad0d1bbb07ed881250f460e9817bc9c50">icarus::opdet::PMTsimulationAlg::DiscriminationAlgo</a> &gt; const icarus::opdet::PMTsimulationAlg::DiscrimAlgoSelector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  </div>
<div class="line">    { <a class="code hl_enumvalue" href="#ad0d1bbb07ed881250f460e9817bc9c50a362b9efdb814a78f5f14520be6ffe3de">DiscriminationAlgo::AboveThreshold</a>,     <span class="stringliteral">&quot;AboveThreshold&quot;</span>    }</div>
<div class="line">  , { <a class="code hl_enumvalue" href="#ad0d1bbb07ed881250f460e9817bc9c50a338847afd26d8b1527f2feaa0ad0f236">DiscriminationAlgo::CrossingThreshold</a>,  <span class="stringliteral">&quot;CrossingThreshold&quot;</span> }</div>
<div class="line">}</div>
<div class="ttc" id="aclassicarus_1_1opdet_1_1PMTsimulationAlg_html_ad0d1bbb07ed881250f460e9817bc9c50a338847afd26d8b1527f2feaa0ad0f236"><div class="ttname"><a href="#ad0d1bbb07ed881250f460e9817bc9c50a338847afd26d8b1527f2feaa0ad0f236">icarus::opdet::PMTsimulationAlg::DiscriminationAlgo::CrossingThreshold</a></div><div class="ttdeci">@ CrossingThreshold</div><div class="ttdoc">Readout triggered when signal crosses threshold.</div></div>
<div class="ttc" id="aclassicarus_1_1opdet_1_1PMTsimulationAlg_html_ad0d1bbb07ed881250f460e9817bc9c50a362b9efdb814a78f5f14520be6ffe3de"><div class="ttname"><a href="#ad0d1bbb07ed881250f460e9817bc9c50a362b9efdb814a78f5f14520be6ffe3de">icarus::opdet::PMTsimulationAlg::DiscriminationAlgo::AboveThreshold</a></div><div class="ttdeci">@ AboveThreshold</div><div class="ttdoc">Readout triggered when signal is above threshold.</div></div>
</div><!-- fragment -->
<p>Manages the conversion between names and values of <code>DiscriminationAlgo</code>. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00061">61</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlgMaker_1_1Config.html#ac1e56d8c915ef467c7a5036d71886293">icarus::opdet::PMTsimulationAlgMaker::Config::getDiscriminationAlgo()</a>.</p>

</div>
</div>
<a id="acede5ff0943f7e8d99481c005498631a" name="acede5ff0943f7e8d99481c005498631a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acede5ff0943f7e8d99481c005498631a">&#9670;&#160;</a></span>fDiscrAlgo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5be1969083b04f9acf947b8f7c9abc3f">DiscriminationAlgoProc_t</a> icarus::opdet::PMTsimulationAlg::fDiscrAlgo = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Member function for the zero suppression discrimination algorithm. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00640">640</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ade12a71e902019f988d3f037226e1d8e">PMTsimulationAlg()</a>.</p>

</div>
</div>
<a id="abc9b79707c1b8f5afc175fdc8cd51eb0" name="abc9b79707c1b8f5afc175fdc8cd51eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9b79707c1b8f5afc175fdc8cd51eb0">&#9670;&#160;</a></span>fNsamples</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t icarus::opdet::PMTsimulationAlg::fNsamples</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Samples per waveform. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00632">632</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="a1021a841e3d7a47a2ff8458c982675ae" name="a1021a841e3d7a47a2ff8458c982675ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1021a841e3d7a47a2ff8458c982675ae">&#9670;&#160;</a></span>fParams</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicarus_1_1opdet_1_1PMTsimulationAlg_1_1ConfigurationParameters__t.html">ConfigurationParameters_t</a> icarus::opdet::PMTsimulationAlg::fParams</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complete algorithm configuration. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00628">628</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ade12a71e902019f988d3f037226e1d8e">PMTsimulationAlg()</a>.</p>

</div>
</div>
<a id="a264cc70d68ed62ae9fa8fcb38e7d3566" name="a264cc70d68ed62ae9fa8fcb38e7d3566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264cc70d68ed62ae9fa8fcb38e7d3566">&#9670;&#160;</a></span>fPedestalGen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceicarus_1_1opdet.html#a07cbeecef714f95f2165098fe548c471">PedestalGenerator_t</a>* icarus::opdet::PMTsimulationAlg::fPedestalGen = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single photon pulse (sampled). </p>
<p>Pedestal and electronics noise generator algorithm. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00637">637</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="af8992f7d6a13f5fa86f0e0a8a68f6b6b" name="af8992f7d6a13f5fa86f0e0a8a68f6b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8992f7d6a13f5fa86f0e0a8a68f6b6b">&#9670;&#160;</a></span>fQE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double icarus::opdet::PMTsimulationAlg::fQE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PMT quantum efficiency. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00630">630</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ade12a71e902019f988d3f037226e1d8e">PMTsimulationAlg()</a>.</p>

</div>
</div>
<a id="a065984ccb1859a6400c2d9f3262eb082" name="a065984ccb1859a6400c2d9f3262eb082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065984ccb1859a6400c2d9f3262eb082">&#9670;&#160;</a></span>fSampling</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">megahertz icarus::opdet::PMTsimulationAlg::fSampling</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wave sampling frequency [MHz]. </p>

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00631">631</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<a id="aa822578c863e4bdcac980b9186f33ec1" name="aa822578c863e4bdcac980b9186f33ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa822578c863e4bdcac980b9186f33ec1">&#9670;&#160;</a></span>wsp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicarus_1_1opdet_1_1DiscretePhotoelectronPulse.html">DiscretePhotoelectronPulse</a> icarus::opdet::PMTsimulationAlg::wsp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PMTsimulationAlg_8h_source.html#l00634">634</a> of file <a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>icaruscode/icaruscode/PMT/Algorithms/<a class="el" href="PMTsimulationAlg_8h_source.html">PMTsimulationAlg.h</a></li>
<li>icaruscode/icaruscode/PMT/Algorithms/<a class="el" href="PMTsimulationAlg_8cxx_source.html">PMTsimulationAlg.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
