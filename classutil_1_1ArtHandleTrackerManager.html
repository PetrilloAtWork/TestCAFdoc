<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAF format: util::ArtHandleTrackerManager&lt; Event &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/TeX/AMSmath','[tex]/TeX/AMSsymbols']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','TeX/AMSmath','TeX/AMSsymbols']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CAF format<span id="projectnumber">&#160;${SBNANAOBJ_VERSION}</span>
   </div>
   <div id="projectbrief">Simulation, reconstruction and analysis software for the ICARUS experiment.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>util</b></li><li class="navelem"><a class="el" href="classutil_1_1ArtHandleTrackerManager.html">ArtHandleTrackerManager</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classutil_1_1ArtHandleTrackerManager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">util::ArtHandleTrackerManager&lt; Event &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Manages handle trackers for an easy call of <code>removeCachedProduct()</code>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structutil_1_1ArtHandleTrackerManager_1_1Config__t" id="r_structutil_1_1ArtHandleTrackerManager_1_1Config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">Config_t</a></td></tr>
<tr class="memdesc:structutil_1_1ArtHandleTrackerManager_1_1Config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration record.  <a href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">More...</a><br /></td></tr>
<tr class="separator:structutil_1_1ArtHandleTrackerManager_1_1Config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2af72427bef2f4c6870c9590d335b285" id="r_a2af72427bef2f4c6870c9590d335b285"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a> = Event</td></tr>
<tr class="memdesc:a2af72427bef2f4c6870c9590d335b285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of data viewer object to operate with.  <br /></td></tr>
<tr class="separator:a2af72427bef2f4c6870c9590d335b285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa53c11994d1fd1400bd6cc3acfb4a0ba" id="r_aa53c11994d1fd1400bd6cc3acfb4a0ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa53c11994d1fd1400bd6cc3acfb4a0ba">ArtHandleTrackerManager</a> (<a class="el" href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">Config_t</a> config={})</td></tr>
<tr class="memdesc:aa53c11994d1fd1400bd6cc3acfb4a0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a handle manager.  <br /></td></tr>
<tr class="separator:aa53c11994d1fd1400bd6cc3acfb4a0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fa2641cf95a090fea69dabd8bf09be" id="r_a67fa2641cf95a090fea69dabd8bf09be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67fa2641cf95a090fea69dabd8bf09be">ArtHandleTrackerManager</a> (<a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a> const &amp;event, <a class="el" href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">Config_t</a> config={})</td></tr>
<tr class="memdesc:a67fa2641cf95a090fea69dabd8bf09be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a handle manager covering <code>event</code>.  <br /></td></tr>
<tr class="separator:a67fa2641cf95a090fea69dabd8bf09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5b00610e6814c9ddb6865aac70c10" id="r_a48e5b00610e6814c9ddb6865aac70c10"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:a48e5b00610e6814c9ddb6865aac70c10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48e5b00610e6814c9ddb6865aac70c10">registerHandle</a> (Handle &amp;&amp;handle) -&gt; decltype(auto)</td></tr>
<tr class="separator:a48e5b00610e6814c9ddb6865aac70c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e1d579ee364ed9ef81d846d1bc2f7f" id="r_aa9e1d579ee364ed9ef81d846d1bc2f7f"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:aa9e1d579ee364ed9ef81d846d1bc2f7f"><td class="memTemplItemLeft" align="right" valign="top">Handle const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9e1d579ee364ed9ef81d846d1bc2f7f">findHandle</a> (Handle const &amp;like) const</td></tr>
<tr class="separator:aa9e1d579ee364ed9ef81d846d1bc2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Queries</div></td></tr>
<tr class="memitem:a647de4c44e9c3e63c0b52ac82a234c77" id="r_a647de4c44e9c3e63c0b52ac82a234c77"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a647de4c44e9c3e63c0b52ac82a234c77">nTrackedHandles</a> () const</td></tr>
<tr class="memdesc:a647de4c44e9c3e63c0b52ac82a234c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of handles currently tracked.  <br /></td></tr>
<tr class="separator:a647de4c44e9c3e63c0b52ac82a234c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7716846c1af6ce2b1a3505345ee9fa1" id="r_ab7716846c1af6ce2b1a3505345ee9fa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7716846c1af6ce2b1a3505345ee9fa1">hasEvent</a> () const</td></tr>
<tr class="memdesc:ab7716846c1af6ce2b1a3505345ee9fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object is associated to an event.  <br /></td></tr>
<tr class="separator:ab7716846c1af6ce2b1a3505345ee9fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Registration of data products</div></td></tr>
<tr class="memitem:ac37f25ccb553874cd3ac2d2906156327" id="r_ac37f25ccb553874cd3ac2d2906156327"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac37f25ccb553874cd3ac2d2906156327"><td class="memTemplItemLeft" align="right" valign="top">art::Handle&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac37f25ccb553874cd3ac2d2906156327">getHandle</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac37f25ccb553874cd3ac2d2906156327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an handle from the event, and registers it.  <br /></td></tr>
<tr class="separator:ac37f25ccb553874cd3ac2d2906156327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162bc51bc10598ff2e2a05e948544e52" id="r_a162bc51bc10598ff2e2a05e948544e52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a162bc51bc10598ff2e2a05e948544e52"><td class="memTemplItemLeft" align="right" valign="top">art::ValidHandle&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a162bc51bc10598ff2e2a05e948544e52">getValidHandle</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a162bc51bc10598ff2e2a05e948544e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a valid handle from the event, and registers it.  <br /></td></tr>
<tr class="separator:a162bc51bc10598ff2e2a05e948544e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d7e421b68023687f415065282a9ac7" id="r_a71d7e421b68023687f415065282a9ac7"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:a71d7e421b68023687f415065282a9ac7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71d7e421b68023687f415065282a9ac7">registerHandle</a> (Handle &amp;&amp;handle)</td></tr>
<tr class="memdesc:a71d7e421b68023687f415065282a9ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an existing handle.  <br /></td></tr>
<tr class="separator:a71d7e421b68023687f415065282a9ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr class="memitem:a036e412f2cfe5dcbf2a626ca31809540" id="r_a036e412f2cfe5dcbf2a626ca31809540"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a036e412f2cfe5dcbf2a626ca31809540">useEvent</a> (<a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a> const &amp;event)</td></tr>
<tr class="memdesc:a036e412f2cfe5dcbf2a626ca31809540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the event being served.  <br /></td></tr>
<tr class="separator:a036e412f2cfe5dcbf2a626ca31809540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619acd185c3273d89635c2cdaaa988f2" id="r_a619acd185c3273d89635c2cdaaa988f2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619acd185c3273d89635c2cdaaa988f2">removeCachedProducts</a> ()</td></tr>
<tr class="memdesc:a619acd185c3273d89635c2cdaaa988f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the cached data products for all tracked handles.  <br /></td></tr>
<tr class="separator:a619acd185c3273d89635c2cdaaa988f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f458caaffb6f243dbf962d1cda40f6" id="r_a14f458caaffb6f243dbf962d1cda40f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14f458caaffb6f243dbf962d1cda40f6">forgetAllHandles</a> ()</td></tr>
<tr class="memdesc:a14f458caaffb6f243dbf962d1cda40f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops tracking any handle, without removing their cache first.  <br /></td></tr>
<tr class="separator:a14f458caaffb6f243dbf962d1cda40f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8ada59ea36b2ce68c97bb60ae5d172" id="r_a9c8ada59ea36b2ce68c97bb60ae5d172"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c8ada59ea36b2ce68c97bb60ae5d172">doneWithEvent</a> (bool removeCache=true, art::Event const *event=nullptr)</td></tr>
<tr class="memdesc:a9c8ada59ea36b2ce68c97bb60ae5d172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the work on the associated <code>event</code>.  <br /></td></tr>
<tr class="separator:a9c8ada59ea36b2ce68c97bb60ae5d172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a34c41a44640229693e1f813d6e69c65d" id="r_a34c41a44640229693e1f813d6e69c65d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34c41a44640229693e1f813d6e69c65d">TrackerPtr</a> = std::unique_ptr&lt;<a class="el" href="structutil_1_1ArtHandleTrackerInterface.html">util::ArtHandleTrackerInterface</a>&lt;<a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a>&gt;&gt;</td></tr>
<tr class="memdesc:a34c41a44640229693e1f813d6e69c65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer to any handle tracker.  <br /></td></tr>
<tr class="separator:a34c41a44640229693e1f813d6e69c65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa9e1d579ee364ed9ef81d846d1bc2f7f" id="r_aa9e1d579ee364ed9ef81d846d1bc2f7f"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:aa9e1d579ee364ed9ef81d846d1bc2f7f"><td class="memTemplItemLeft" align="right" valign="top">Handle const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9e1d579ee364ed9ef81d846d1bc2f7f">findHandle</a> (Handle const &amp;like) const</td></tr>
<tr class="memdesc:aa9e1d579ee364ed9ef81d846d1bc2f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to an handle equivalent to <code>like</code>.  <br /></td></tr>
<tr class="separator:aa9e1d579ee364ed9ef81d846d1bc2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3445315cdbe20d0c4f7de21e6697e093" id="r_a3445315cdbe20d0c4f7de21e6697e093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3445315cdbe20d0c4f7de21e6697e093">canOperate</a> (const char *where) const</td></tr>
<tr class="separator:a3445315cdbe20d0c4f7de21e6697e093"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a5269580c0fdc51221b81776c5a3eba43" id="r_a5269580c0fdc51221b81776c5a3eba43"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:a5269580c0fdc51221b81776c5a3eba43"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5269580c0fdc51221b81776c5a3eba43">handleSameProduct</a> (<a class="el" href="#a34c41a44640229693e1f813d6e69c65d">TrackerPtr</a> tracker, Handle const &amp;handle)</td></tr>
<tr class="memdesc:a5269580c0fdc51221b81776c5a3eba43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>tracker</code> tracks the same product that <code>handle</code> handles.  <br /></td></tr>
<tr class="separator:a5269580c0fdc51221b81776c5a3eba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afc264b07a9267c83468c95ef51526638" id="r_afc264b07a9267c83468c95ef51526638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc264b07a9267c83468c95ef51526638">fEvent</a> = nullptr</td></tr>
<tr class="memdesc:afc264b07a9267c83468c95ef51526638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event being manager. Must be present!  <br /></td></tr>
<tr class="separator:afc264b07a9267c83468c95ef51526638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd987441e10aa05eeed66ed383b22d2b" id="r_acd987441e10aa05eeed66ed383b22d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">Config_t</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd987441e10aa05eeed66ed383b22d2b">fConfig</a></td></tr>
<tr class="memdesc:acd987441e10aa05eeed66ed383b22d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration.  <br /></td></tr>
<tr class="separator:acd987441e10aa05eeed66ed383b22d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700ac1080e7b3c229715611717c4e2ad" id="r_a700ac1080e7b3c229715611717c4e2ad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="#a34c41a44640229693e1f813d6e69c65d">TrackerPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a700ac1080e7b3c229715611717c4e2ad">fTrackers</a></td></tr>
<tr class="memdesc:a700ac1080e7b3c229715611717c4e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of managed handle trackers.  <br /></td></tr>
<tr class="separator:a700ac1080e7b3c229715611717c4e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Event&gt;<br />
class util::ArtHandleTrackerManager&lt; Event &gt;</div><p>Manages handle trackers for an easy call of <code>removeCachedProduct()</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event</td><td>the type of data product source (the "principal") to serve</td></tr>
  </table>
  </dd>
</dl>
<p>This handle manager is designed to simplify the usage of <code>art::Event::removeCachedProduct()</code> on multiple data products.</p>
<p>The envisioned usage model in a single-thread module is the following:</p><ol type="1">
<li>The manager is a data member of the module (in alternative, it should be passed down to the places where data products are read, and at a minimum it needs to register all the handles it is supposed to "manage").</li>
<li>The manager can ask the event to read a data product anew, and get an handle for it. It will register the handle, and return it.<ul>
<li>The manager can also register an existing handle.</li>
</ul>
</li>
<li>The manager can deliver a stored handle (but that's a slow process in the current implementation and it requires the input tag to resolve ambiguities).</li>
<li>Upon request, all handles are asked to remove their cached products. This request presumably happens at the end of the event-processing function (<code>produce()</code>, <code>filter()</code>, <code>analyze()</code>). Note that after an handle has its cached data removed, it's <code>clear()</code>'ed.</li>
</ol>
<p>An handle manager can serve only one <em>art</em> event at a time. All handles come from that event (or are assumed to).</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyModule: <span class="keyword">public</span> art::EDAnalyzer {</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager&lt;art::Event&gt;</a> fDataCacheRemover;</div>
<div class="line">  </div>
<div class="line">  art::InputTag <span class="keyword">const</span> fTag;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">void</span> analyze(art::Event <span class="keyword">const</span> &amp; event)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      fDataCacheRemover.<a class="code hl_function" href="#a036e412f2cfe5dcbf2a626ca31809540">useEvent</a>(event);</div>
<div class="line">      </div>
<div class="line">      <span class="keyword">auto</span> <span class="keyword">const</span>&amp; handle = fDataCacheRemover.<a class="code hl_function" href="#ac37f25ccb553874cd3ac2d2906156327">getHandle</a>&lt;MyDataProduct&gt;(fTag);</div>
<div class="line">      </div>
<div class="line">      <span class="keyword">auto</span> results = processData(*handle); <span class="comment">// ... or whatever</span></div>
<div class="line">      </div>
<div class="line">      fDataCacheRemover.<a class="code hl_function" href="#a619acd185c3273d89635c2cdaaa988f2">removeCachedProducts</a>(); <span class="comment">// free caches after use</span></div>
<div class="line">      </div>
<div class="line">      results.Write(); <span class="comment">// ... or another portion of whatever</span></div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line">};</div>
<div class="ttc" id="aclassutil_1_1ArtHandleTrackerManager_html"><div class="ttname"><a href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a></div><div class="ttdoc">Manages handle trackers for an easy call of removeCachedProduct().</div><div class="ttdef"><b>Definition</b> <a href="ArtHandleTrackerManager_8h_source.html#l00159">ArtHandleTrackerManager.h:159</a></div></div>
<div class="ttc" id="aclassutil_1_1ArtHandleTrackerManager_html_a036e412f2cfe5dcbf2a626ca31809540"><div class="ttname"><a href="#a036e412f2cfe5dcbf2a626ca31809540">util::ArtHandleTrackerManager::useEvent</a></div><div class="ttdeci">void useEvent(Event_t const &amp;event)</div><div class="ttdoc">Changes the event being served.</div><div class="ttdef"><b>Definition</b> <a href="ArtHandleTrackerManager_8h_source.html#l00798">ArtHandleTrackerManager.h:798</a></div></div>
<div class="ttc" id="aclassutil_1_1ArtHandleTrackerManager_html_a619acd185c3273d89635c2cdaaa988f2"><div class="ttname"><a href="#a619acd185c3273d89635c2cdaaa988f2">util::ArtHandleTrackerManager::removeCachedProducts</a></div><div class="ttdeci">unsigned int removeCachedProducts()</div><div class="ttdoc">Clears the cached data products for all tracked handles.</div><div class="ttdef"><b>Definition</b> <a href="ArtHandleTrackerManager_8h_source.html#l00909">ArtHandleTrackerManager.h:909</a></div></div>
<div class="ttc" id="aclassutil_1_1ArtHandleTrackerManager_html_ac37f25ccb553874cd3ac2d2906156327"><div class="ttname"><a href="#ac37f25ccb553874cd3ac2d2906156327">util::ArtHandleTrackerManager::getHandle</a></div><div class="ttdeci">art::Handle&lt; T &gt; getHandle(Args &amp;&amp;... args)</div><div class="ttdoc">Retrieves an handle from the event, and registers it.</div><div class="ttdef"><b>Definition</b> <a href="ArtHandleTrackerManager_8h_source.html#l00817">ArtHandleTrackerManager.h:818</a></div></div>
</div><!-- fragment --><p>Or one can create the handle as preferred, and then register it: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyModule: <span class="keyword">public</span> art::EDAnalyzer {</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager&lt;art::Event&gt;</a> fDataCacheRemover;</div>
<div class="line">  </div>
<div class="line">  art::InputTag <span class="keyword">const</span> fTag;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">void</span> analyze(art::Event <span class="keyword">const</span> &amp; event)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      fDataCacheRemover.<a class="code hl_function" href="#a036e412f2cfe5dcbf2a626ca31809540">useEvent</a>(event);</div>
<div class="line">      </div>
<div class="line">      <span class="keyword">auto</span> <span class="keyword">const</span>&amp; handle = <span class="keyword">event</span>.getValidHandle&lt;MyDataProduct&gt;(fTag);</div>
<div class="line">      </div>
<div class="line">      fDataCacheRemover.<a class="code hl_function" href="#a71d7e421b68023687f415065282a9ac7">registerHandle</a>(handle);</div>
<div class="line">      </div>
<div class="line">      <span class="keyword">auto</span> results = processData(*handle); <span class="comment">// ... or whatever</span></div>
<div class="line">      </div>
<div class="line">      fDataCacheRemover.<a class="code hl_function" href="#a619acd185c3273d89635c2cdaaa988f2">removeCachedProducts</a>(); <span class="comment">// free caches after use</span></div>
<div class="line">      </div>
<div class="line">      results.Write(); <span class="comment">// ... or another portion of whatever</span></div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line">};</div>
<div class="ttc" id="aclassutil_1_1ArtHandleTrackerManager_html_a71d7e421b68023687f415065282a9ac7"><div class="ttname"><a href="#a71d7e421b68023687f415065282a9ac7">util::ArtHandleTrackerManager::registerHandle</a></div><div class="ttdeci">decltype(auto) registerHandle(Handle &amp;&amp;handle)</div><div class="ttdoc">Registers an existing handle.</div></div>
</div><!-- fragment --><h1>Technical notes </h1>
<h2>Support for different types of handles </h2>
<p>Currently, both <code>art::Handle</code> and <code>art::ValidHandle</code> (and nothing else) can be created by <code><a class="el" href="classutil_1_1ArtHandleTrackerManager.html" title="Manages handle trackers for an easy call of removeCachedProduct().">ArtHandleTrackerManager</a></code>. The code can be extended to support any object that can be passed to <code>art::Event::removeCachedProduct()</code> (e.g. <code>art::ProductID</code>, if it will ever happen).</p>
<p>The current implementation is expected to be able to recognize handles pointing to the same data product even if they are of different type (e.g. <code>art::Handle&lt;T&gt;</code> and <code>art::ValidHandle&lt;T&gt;</code>). The manager stores a copy of the first type of handle registered for a given data product; then, if another handle of any type to the same data product is requested or registered, <code><a class="el" href="#a71d7e421b68023687f415065282a9ac7" title="Registers an existing handle.">registerHandle()</a></code> will return the same handle in argument, and the <code><a class="el" href="#ac37f25ccb553874cd3ac2d2906156327" title="Retrieves an handle from the event, and registers it.">getHandle()</a></code> family of functions will get and return a new handle. In both cases, no new registration will happen.</p>
<h2>Multithreading </h2>
<p>The current implementation is inherently not safe for <em>art</em> multithreading. While the inner data structure don't need global state, and the interface can easily be extended to allow for no global state as well, the operations are still performed on all the registered handles at once (meaning, when one thread asks for <code>removeCachedProduct()</code> or <code><a class="el" href="#a14f458caaffb6f243dbf962d1cda40f6" title="Stops tracking any handle, without removing their cache first.">forgetAllHandles()</a></code>, data from all events is affected). This can be overcome by changing the internal storage (to be reentrant and possibly by event) and a bit of the interface.</p>
<p>The object as it is now can be implemented on top of such object, preserving the current event information and delivering it to the new manager under the hood, with minimal overhead.</p>
<p>If such feature is needed, ask the author (and be prepared to test it). </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00159">159</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structutil_1_1ArtHandleTrackerManager_1_1Config__t" id="structutil_1_1ArtHandleTrackerManager_1_1Config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">&#9670;&#160;</a></span>util::ArtHandleTrackerManager::Config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct util::ArtHandleTrackerManager::Config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Event&gt;<br />
struct util::ArtHandleTrackerManager&lt; Event &gt;::Config_t</div><p>Configuration record. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00166">166</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a3fb939d8e4eae118acd6d96cfbfa532d" name="a3fb939d8e4eae118acd6d96cfbfa532d"></a>string</td>
<td class="fieldname">
logCategory = &quot;ArtHandleTrackerManager&quot;</td>
<td class="fielddoc">
Name of the output category for messages. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2af72427bef2f4c6870c9590d335b285" name="a2af72427bef2f4c6870c9590d335b285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af72427bef2f4c6870c9590d335b285">&#9670;&#160;</a></span>Event_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::Event_t = Event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of data viewer object to operate with. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00163">163</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a34c41a44640229693e1f813d6e69c65d" name="a34c41a44640229693e1f813d6e69c65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c41a44640229693e1f813d6e69c65d">&#9670;&#160;</a></span>TrackerPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::TrackerPtr = std::unique_ptr&lt;<a class="el" href="structutil_1_1ArtHandleTrackerInterface.html">util::ArtHandleTrackerInterface</a>&lt;<a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a>&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of pointer to any handle tracker. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00322">322</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa53c11994d1fd1400bd6cc3acfb4a0ba" name="aa53c11994d1fd1400bd6cc3acfb4a0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53c11994d1fd1400bd6cc3acfb4a0ba">&#9670;&#160;</a></span>ArtHandleTrackerManager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::ArtHandleTrackerManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">Config_t</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a handle manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>(optional) the configuration to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a036e412f2cfe5dcbf2a626ca31809540" title="Changes the event being served.">useEvent()</a></code></dd></dl>
<p>An event must be later assigned to it (<code><a class="el" href="#a036e412f2cfe5dcbf2a626ca31809540" title="Changes the event being served.">useEvent()</a></code>) to make it functional. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00782">782</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a67fa2641cf95a090fea69dabd8bf09be" name="a67fa2641cf95a090fea69dabd8bf09be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fa2641cf95a090fea69dabd8bf09be">&#9670;&#160;</a></span>ArtHandleTrackerManager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::ArtHandleTrackerManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">Config_t</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a handle manager covering <code>event</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>the first data viewer (event) object to operate on </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00790">790</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3445315cdbe20d0c4f7de21e6697e093" name="a3445315cdbe20d0c4f7de21e6697e093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3445315cdbe20d0c4f7de21e6697e093">&#9670;&#160;</a></span>canOperate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::canOperate </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>where</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks that the object is in a state where it can perform operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">where</td><td>identification of the calling function for error messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">art::Exception</td><td>(code: <code>art::errors::LogicError</code>) on failure </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00994">994</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a9c8ada59ea36b2ce68c97bb60ae5d172" name="a9c8ada59ea36b2ce68c97bb60ae5d172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8ada59ea36b2ce68c97bb60ae5d172">&#9670;&#160;</a></span>doneWithEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::doneWithEvent </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>removeCache</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event const *</td>          <td class="paramname"><span class="paramname"><em>event</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes the work on the associated <code>event</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">removeCache</td><td>(default: <code>true</code>) removes tracked data product caches </td></tr>
    <tr><td class="paramname">event</td><td>if specified, only acts on cache from this <code>event</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cleared data product caches</dd></dl>
<p>This is a shortcut for having optional release of cache in a single call, depending on the value of <code>removeCache</code>:</p><ul>
<li>if <code>true</code>, <code><a class="el" href="#a619acd185c3273d89635c2cdaaa988f2" title="Clears the cached data products for all tracked handles.">removeCachedProducts()</a></code> is called and its count is returned;</li>
<li>if <code>false</code>, <code><a class="el" href="#a14f458caaffb6f243dbf962d1cda40f6" title="Stops tracking any handle, without removing their cache first.">forgetAllHandles()</a></code> is called and <code>0</code> is returned.</li>
</ul>
<p>In addition, the object is disassociated from the event, and a call to <code><a class="el" href="#a036e412f2cfe5dcbf2a626ca31809540" title="Changes the event being served.">useEvent()</a></code> will be needed before this object can be operative again.</p>
<p>If the <code>event</code> parameter is not null, a check is done that the event being currently used matches <code>event</code>, and if not no operation happens (<code>0</code> is returned, but the object is not disassociated from its current event). </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00933">933</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="aa9e1d579ee364ed9ef81d846d1bc2f7f" name="aa9e1d579ee364ed9ef81d846d1bc2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e1d579ee364ed9ef81d846d1bc2f7f">&#9670;&#160;</a></span>findHandle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Handle const  * <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::findHandle </td>
          <td>(</td>
          <td class="paramtype">Handle const &amp;</td>          <td class="paramname"><span class="paramname"><em>like</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to an handle equivalent to <code>like</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle</td><td>the type of the handle being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the handle, or <code>nullptr</code> if not found</dd></dl>
<p>This is an half-assed method since it needs to know already the exact type of the handle being queried (it's not even agnostic to the difference between <code>art::Handle</code> and <code>art::ValidHandle</code>). For this reason, it's not really useful to the users, who would probably want to know if the data product is cached, via any mean.</p>
<h3>Technical note</h3>
<p>Delegating the matching to <code><a class="el" href="structutil_1_1ArtHandleTrackerInterface.html" title="Interface to facilitate the use of util::ArtHandleTracker specializations.">util::ArtHandleTrackerInterface</a></code> is not possible (<code>like</code> is a template parameter and can't be passed via virtual interface) and even working around that and finding the match, the returned value needs to be of type <code>Handle</code>, which is not necessarily the type of handle stored in the tracker.</p>
<p>For the full functionality of knowing if a data product is tracked, a separate registry may be kept, still complicated by the fact that part of the registry entry is a C++ type (we may need to store a sanitized <code>std::type_info</code> for that). </p>

</div>
</div>
<a id="aa9e1d579ee364ed9ef81d846d1bc2f7f" name="aa9e1d579ee364ed9ef81d846d1bc2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e1d579ee364ed9ef81d846d1bc2f7f">&#9670;&#160;</a></span>findHandle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Handle const  * <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::findHandle </td>
          <td>(</td>
          <td class="paramtype">Handle const &amp;</td>          <td class="paramname"><span class="paramname"><em>like</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00951">951</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a14f458caaffb6f243dbf962d1cda40f6" name="a14f458caaffb6f243dbf962d1cda40f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f458caaffb6f243dbf962d1cda40f6">&#9670;&#160;</a></span>forgetAllHandles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::forgetAllHandles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops tracking any handle, without removing their cache first. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00925">925</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classutil_1_1LocalArtHandleTrackerManager.html#a955378d711b2e660710f98e3ad14e6fb">util::LocalArtHandleTrackerManager&lt; Event &gt;::forgetAllHandles()</a>.</p>

</div>
</div>
<a id="ac37f25ccb553874cd3ac2d2906156327" name="ac37f25ccb553874cd3ac2d2906156327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37f25ccb553874cd3ac2d2906156327">&#9670;&#160;</a></span>getHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">art::Handle&lt; T &gt; <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::getHandle </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an handle from the event, and registers it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data product to retrieve </td></tr>
    <tr><td class="paramname">Args</td><td>types of the arguments needed by <code>art::getHandle()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>all the arguments that <code>art::getHandle()</code> requires </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle just read and being managed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a162bc51bc10598ff2e2a05e948544e52" title="Retrieves a valid handle from the event, and registers it.">getValidHandle()</a></code>, <code><a class="el" href="#a71d7e421b68023687f415065282a9ac7" title="Registers an existing handle.">registerHandle()</a></code></dd></dl>
<p>This function wraps <code>art::Event::getHandle()</code>, calling it to obtain the handle and then registering it (like with <code><a class="el" href="#a71d7e421b68023687f415065282a9ac7" title="Registers an existing handle.">registerHandle()</a></code>). </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00817">817</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a162bc51bc10598ff2e2a05e948544e52" name="a162bc51bc10598ff2e2a05e948544e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162bc51bc10598ff2e2a05e948544e52">&#9670;&#160;</a></span>getValidHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">art::ValidHandle&lt; T &gt; <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::getValidHandle </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a valid handle from the event, and registers it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data product to retrieve </td></tr>
    <tr><td class="paramname">Args</td><td>types of the arguments needed by <code>art::getValidHandle()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>all the arguments that <code>art::getValidHandle()</code> requires </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle just read and being managed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ac37f25ccb553874cd3ac2d2906156327" title="Retrieves an handle from the event, and registers it.">getHandle()</a></code>, <code><a class="el" href="#a71d7e421b68023687f415065282a9ac7" title="Registers an existing handle.">registerHandle()</a></code></dd></dl>
<p>This is the <code>art::ValidHandle</code> sibling of <code><a class="el" href="#ac37f25ccb553874cd3ac2d2906156327" title="Retrieves an handle from the event, and registers it.">getHandle()</a></code>. See that one for details. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00829">829</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a5269580c0fdc51221b81776c5a3eba43" name="a5269580c0fdc51221b81776c5a3eba43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5269580c0fdc51221b81776c5a3eba43">&#9670;&#160;</a></span>handleSameProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::handleSameProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a34c41a44640229693e1f813d6e69c65d">TrackerPtr</a></td>          <td class="paramname"><span class="paramname"><em>tracker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle const &amp;</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>tracker</code> tracks the same product that <code>handle</code> handles. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00977">977</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="ab7716846c1af6ce2b1a3505345ee9fa1" name="ab7716846c1af6ce2b1a3505345ee9fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7716846c1af6ce2b1a3505345ee9fa1">&#9670;&#160;</a></span>hasEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::hasEvent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the object is associated to an event. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00903">903</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classutil_1_1LocalArtHandleTrackerManager.html#afecccfa75a4a8c3cc33f8a3388003374">util::LocalArtHandleTrackerManager&lt; Event &gt;::doneWithEvent()</a>.</p>

</div>
</div>
<a id="a647de4c44e9c3e63c0b52ac82a234c77" name="a647de4c44e9c3e63c0b52ac82a234c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647de4c44e9c3e63c0b52ac82a234c77">&#9670;&#160;</a></span>nTrackedHandles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::nTrackedHandles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of handles currently tracked. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00897">897</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classutil_1_1LocalArtHandleTrackerManager.html#aef0617f7719d8f37cc6f360149f060a0">util::LocalArtHandleTrackerManager&lt; Event &gt;::nTrackedHandles()</a>.</p>

</div>
</div>
<a id="a71d7e421b68023687f415065282a9ac7" name="a71d7e421b68023687f415065282a9ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d7e421b68023687f415065282a9ac7">&#9670;&#160;</a></span>registerHandle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::registerHandle </td>
          <td>(</td>
          <td class="paramtype">Handle &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an existing handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle</td><td>the type of handle to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the handle to be registered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>handle</code> (pass through)</dd></dl>
<p>This method registers a copy of <code>handle</code> into the manager. </p>

<p class="reference">Referenced by <a class="el" href="classicarus_1_1DaqDecoderICARUSPMT.html#afed7b8714e50bef1ec6635a5564538cb">icarus::DaqDecoderICARUSPMT::readInputFragments()</a>.</p>

</div>
</div>
<a id="a48e5b00610e6814c9ddb6865aac70c10" name="a48e5b00610e6814c9ddb6865aac70c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e5b00610e6814c9ddb6865aac70c10">&#9670;&#160;</a></span>registerHandle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::registerHandle </td>
          <td>(</td>
          <td class="paramtype">Handle &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td> -&gt; decltype(auto)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00849">849</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a619acd185c3273d89635c2cdaaa988f2" name="a619acd185c3273d89635c2cdaaa988f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619acd185c3273d89635c2cdaaa988f2">&#9670;&#160;</a></span>removeCachedProducts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::removeCachedProducts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the cached data products for all tracked handles. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tracked handles which had their cache removed</dd></dl>
<p>This method calls <code>Event_t::removeCachedProduct()</code> for all tracked handles. This is the core functionality of the manager, which removes the cache of all tracked handles.</p>
<p>The <em>art</em> framework always makes the handles used to remove the cache invalid (<code>Handle::clear()</code>). After the removal, the object stops tracking the handles (like with a call to <code><a class="el" href="#a14f458caaffb6f243dbf962d1cda40f6" title="Stops tracking any handle, without removing their cache first.">forgetAllHandles()</a></code>).</p>
<p>Calling this method when there are no handles registered has no effect. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00909">909</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classicarus_1_1DaqDecoderICARUSPMT.html#ae787bc4b86f2a6cdc478df20d233b604">icarus::DaqDecoderICARUSPMT::produce()</a>, and <a class="el" href="classutil_1_1LocalArtHandleTrackerManager.html#a59a837d32804025f9c3dfa5b73a5377f">util::LocalArtHandleTrackerManager&lt; Event &gt;::removeCachedProducts()</a>.</p>

</div>
</div>
<a id="a036e412f2cfe5dcbf2a626ca31809540" name="a036e412f2cfe5dcbf2a626ca31809540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e412f2cfe5dcbf2a626ca31809540">&#9670;&#160;</a></span>useEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::useEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the event being served. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>the new event being served </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">art::Exception</td><td>(code: <code>art::errors::LogicError</code>) if there are still registered handles</td></tr>
  </table>
  </dd>
</dl>
<p>The object starts tracking handles of a new event.</p>
<p>This method requires that any pending handle has been taken care of (even if the new event happens to be the same as the old one). Common options are <code>removeCachedProductsAndForget()</code> if cache removal is desired, or <code><a class="el" href="#a14f458caaffb6f243dbf962d1cda40f6" title="Stops tracking any handle, without removing their cache first.">forgetAllHandles()</a></code> if it's not. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00798">798</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classicarus_1_1DaqDecoderICARUSPMT.html#ae787bc4b86f2a6cdc478df20d233b604">icarus::DaqDecoderICARUSPMT::produce()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acd987441e10aa05eeed66ed383b22d2b" name="acd987441e10aa05eeed66ed383b22d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd987441e10aa05eeed66ed383b22d2b">&#9670;&#160;</a></span>fConfig</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structutil_1_1ArtHandleTrackerManager_1_1Config__t">Config_t</a> const <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::fConfig</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configuration. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00328">328</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="afc264b07a9267c83468c95ef51526638" name="afc264b07a9267c83468c95ef51526638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc264b07a9267c83468c95ef51526638">&#9670;&#160;</a></span>fEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2af72427bef2f4c6870c9590d335b285">Event_t</a> const* <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::fEvent = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event being manager. Must be present! </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00326">326</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<a id="a700ac1080e7b3c229715611717c4e2ad" name="a700ac1080e7b3c229715611717c4e2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700ac1080e7b3c229715611717c4e2ad">&#9670;&#160;</a></span>fTrackers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="#a34c41a44640229693e1f813d6e69c65d">TrackerPtr</a>&gt; <a class="el" href="classutil_1_1ArtHandleTrackerManager.html">util::ArtHandleTrackerManager</a>&lt; Event &gt;::fTrackers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of managed handle trackers. </p>

<p class="definition">Definition at line <a class="el" href="ArtHandleTrackerManager_8h_source.html#l00331">331</a> of file <a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>icaruscode/icaruscode/Utilities/<a class="el" href="ArtHandleTrackerManager_8h_source.html">ArtHandleTrackerManager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
