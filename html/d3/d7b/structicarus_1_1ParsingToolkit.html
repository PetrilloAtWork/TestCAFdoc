<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAF format: icarus::ParsingToolkit Struct Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/TeX/AMSmath','[tex]/TeX/AMSsymbols']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','TeX/AMSmath','TeX/AMSsymbols']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CAF format<span id="projectnumber">&#160;${SBNANAOBJ_VERSION}</span>
   </div>
   <div id="projectbrief">Simulation, reconstruction and analysis software for the ICARUS experiment.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../da/d4d/namespaceicarus.html">icarus</a></li><li class="navelem"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html">ParsingToolkit</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d8/d82/structicarus_1_1ParsingToolkit-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">icarus::ParsingToolkit Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utilities for text parsing.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d5f/structicarus_1_1ParsingToolkit_1_1CCTypeAdapter.html">CCTypeAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dce/structicarus_1_1ParsingToolkit_1_1Error.html">Error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d61/structicarus_1_1ParsingToolkit_1_1Params__t" id="r_da/d61/structicarus_1_1ParsingToolkit_1_1Params__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a></td></tr>
<tr class="memdesc:da/d61/structicarus_1_1ParsingToolkit_1_1Params__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">All parsing parameters.  <a href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">More...</a><br /></td></tr>
<tr class="separator:da/d61/structicarus_1_1ParsingToolkit_1_1Params__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t" id="r_dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t">SplitView_t</a></td></tr>
<tr class="memdesc:dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record of a split token: pre-separator, separator and post-separator.  <a href="#dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t">More...</a><br /></td></tr>
<tr class="separator:dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9fae443451384bddeecef2c0237c5f27" id="r_a9fae443451384bddeecef2c0237c5f27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> = std::pair&lt;std::string, std::string&gt;</td></tr>
<tr class="memdesc:a9fae443451384bddeecef2c0237c5f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specification of quotation: opening and closing.  <br /></td></tr>
<tr class="separator:a9fae443451384bddeecef2c0237c5f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c0771b23b03681072f28a87950c04e5" id="r_a0c0771b23b03681072f28a87950c04e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c0771b23b03681072f28a87950c04e5">ParsingToolkit</a> ()</td></tr>
<tr class="memdesc:a0c0771b23b03681072f28a87950c04e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parsing parameters.  <br /></td></tr>
<tr class="separator:a0c0771b23b03681072f28a87950c04e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c911af179a04d12b4da58e68be9d019" id="r_a1c911af179a04d12b4da58e68be9d019"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c911af179a04d12b4da58e68be9d019">ParsingToolkit</a> (<a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a> <a class="el" href="#a18d4186db8f1859bab3cf1e8f30a2345">params</a>)</td></tr>
<tr class="memdesc:a1c911af179a04d12b4da58e68be9d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a parser with the specified parsing parameters.  <br /></td></tr>
<tr class="separator:a1c911af179a04d12b4da58e68be9d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d4186db8f1859bab3cf1e8f30a2345" id="r_a18d4186db8f1859bab3cf1e8f30a2345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18d4186db8f1859bab3cf1e8f30a2345">params</a> () const noexcept</td></tr>
<tr class="memdesc:a18d4186db8f1859bab3cf1e8f30a2345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current parameters of parsing.  <br /></td></tr>
<tr class="separator:a18d4186db8f1859bab3cf1e8f30a2345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdc2cfe194a1a95b3e58d45fdb47c72" id="r_aacdc2cfe194a1a95b3e58d45fdb47c72"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:aacdc2cfe194a1a95b3e58d45fdb47c72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacdc2cfe194a1a95b3e58d45fdb47c72">isCharacterEscaped</a> (Iter begin, Iter itCh) const</td></tr>
<tr class="separator:aacdc2cfe194a1a95b3e58d45fdb47c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input</div></td></tr>
<tr class="memitem:a4c34c1b8eec9fd1f6a66f88936e07c98" id="r_a4c34c1b8eec9fd1f6a66f88936e07c98"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c34c1b8eec9fd1f6a66f88936e07c98">readMultiline</a> (std::istream &amp;in) const</td></tr>
<tr class="memdesc:a4c34c1b8eec9fd1f6a66f88936e07c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single line of text from the input stream.  <br /></td></tr>
<tr class="separator:a4c34c1b8eec9fd1f6a66f88936e07c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Characters</div></td></tr>
<tr class="memitem:a2649b2c20a14a6958ab20d66585332cd" id="r_a2649b2c20a14a6958ab20d66585332cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2649b2c20a14a6958ab20d66585332cd">isEscape</a> (char ch) const</td></tr>
<tr class="memdesc:a2649b2c20a14a6958ab20d66585332cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>ch</code> is an escape character.  <br /></td></tr>
<tr class="separator:a2649b2c20a14a6958ab20d66585332cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafe2b9c538e8e3571523e86534f12bf" id="r_adafe2b9c538e8e3571523e86534f12bf"><td class="memTemplParams" colspan="2">template&lt;typename BIter &gt; </td></tr>
<tr class="memitem:adafe2b9c538e8e3571523e86534f12bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adafe2b9c538e8e3571523e86534f12bf">isCharacterEscaped</a> (BIter begin, BIter itCh) const</td></tr>
<tr class="memdesc:adafe2b9c538e8e3571523e86534f12bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the character pointed by <code>itCh</code> is escaped or not.  <br /></td></tr>
<tr class="separator:adafe2b9c538e8e3571523e86534f12bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3a27d4a423ae42c7e98c182b4154be" id="r_a2b3a27d4a423ae42c7e98c182b4154be"><td class="memTemplParams" colspan="2">template&lt;typename Sel &gt; </td></tr>
<tr class="memitem:a2b3a27d4a423ae42c7e98c182b4154be"><td class="memTemplItemLeft" align="right" valign="top">std::string_view::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b3a27d4a423ae42c7e98c182b4154be">findNextCharacter</a> (std::string_view s, Sel select) const</td></tr>
<tr class="memdesc:a2b3a27d4a423ae42c7e98c182b4154be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next character satisfying the specified criterion.  <br /></td></tr>
<tr class="separator:a2b3a27d4a423ae42c7e98c182b4154be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5d545ee1dad7786e27f8240e85f64e" id="r_a6a5d545ee1dad7786e27f8240e85f64e"><td class="memItemLeft" align="right" valign="top">std::string_view::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5d545ee1dad7786e27f8240e85f64e">findNextBlank</a> (std::string_view s) const</td></tr>
<tr class="memdesc:a6a5d545ee1dad7786e27f8240e85f64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <code>findNextCharacter(std::string_view, Sel)</code>.  <br /></td></tr>
<tr class="separator:a6a5d545ee1dad7786e27f8240e85f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c8bcc0d9559e642a5beeeec9d840b" id="r_aea0c8bcc0d9559e642a5beeeec9d840b"><td class="memTemplParams" colspan="2">template&lt;typename CType &gt; </td></tr>
<tr class="memitem:aea0c8bcc0d9559e642a5beeeec9d840b"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea0c8bcc0d9559e642a5beeeec9d840b">removeTrailingCharacters</a> (std::string_view s, CType charType) const</td></tr>
<tr class="memdesc:aea0c8bcc0d9559e642a5beeeec9d840b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes the blank characters a the beginning of <code>s</code>.  <br /></td></tr>
<tr class="separator:aea0c8bcc0d9559e642a5beeeec9d840b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d20ba31cc977d0387762f2bff248388" id="r_a4d20ba31cc977d0387762f2bff248388"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d20ba31cc977d0387762f2bff248388">removeTrailingBlanks</a> (std::string_view s) const</td></tr>
<tr class="memdesc:a4d20ba31cc977d0387762f2bff248388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes the blank characters a the beginning of <code>s</code>.  <br /></td></tr>
<tr class="separator:a4d20ba31cc977d0387762f2bff248388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5888a2857106d9d377334db736070a" id="r_aac5888a2857106d9d377334db736070a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac5888a2857106d9d377334db736070a">removeWordEscapes</a> (std::string &amp;&amp;w) const</td></tr>
<tr class="memdesc:aac5888a2857106d9d377334db736070a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>w</code> with all escape characters removed.  <br /></td></tr>
<tr class="separator:aac5888a2857106d9d377334db736070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00075aa46063a35041b70a6483f4945" id="r_ad00075aa46063a35041b70a6483f4945"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad00075aa46063a35041b70a6483f4945">removeWordEscapes</a> (std::string_view w) const</td></tr>
<tr class="memdesc:ad00075aa46063a35041b70a6483f4945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>ch</code> is an escape character.  <br /></td></tr>
<tr class="separator:ad00075aa46063a35041b70a6483f4945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88acdad6a0258dda93b420fb12ba0aa" id="r_aa88acdad6a0258dda93b420fb12ba0aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa88acdad6a0258dda93b420fb12ba0aa">removeWordEscapes</a> (const char *w) const</td></tr>
<tr class="memdesc:aa88acdad6a0258dda93b420fb12ba0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>ch</code> is an escape character.  <br /></td></tr>
<tr class="separator:aa88acdad6a0258dda93b420fb12ba0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c2e4d6f3dc6a9892c1246d87aec9ec" id="r_a39c2e4d6f3dc6a9892c1246d87aec9ec"><td class="memTemplParams" colspan="2">template&lt;typename Words &gt; </td></tr>
<tr class="memitem:a39c2e4d6f3dc6a9892c1246d87aec9ec"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39c2e4d6f3dc6a9892c1246d87aec9ec">removeEscapes</a> (Words const &amp;words) const</td></tr>
<tr class="memdesc:a39c2e4d6f3dc6a9892c1246d87aec9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>words</code> with all escape characters removed.  <br /></td></tr>
<tr class="separator:a39c2e4d6f3dc6a9892c1246d87aec9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a56eace9f2404e51d7bdd8289770af" id="r_a74a56eace9f2404e51d7bdd8289770af"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a56eace9f2404e51d7bdd8289770af">removeWordQuotations</a> (std::string &amp;&amp;w) const</td></tr>
<tr class="memdesc:a74a56eace9f2404e51d7bdd8289770af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>w</code> with no quotation starts and ends.  <br /></td></tr>
<tr class="separator:a74a56eace9f2404e51d7bdd8289770af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca43c92fcc028a442a6ced5c0245e9d3" id="r_aca43c92fcc028a442a6ced5c0245e9d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca43c92fcc028a442a6ced5c0245e9d3">removeWordQuotations</a> (std::string_view w) const</td></tr>
<tr class="memdesc:aca43c92fcc028a442a6ced5c0245e9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>ch</code> is an escape character.  <br /></td></tr>
<tr class="separator:aca43c92fcc028a442a6ced5c0245e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f217840a0c2203802d2635db0e4775" id="r_ae4f217840a0c2203802d2635db0e4775"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4f217840a0c2203802d2635db0e4775">removeWordQuotations</a> (const char *w) const</td></tr>
<tr class="memdesc:ae4f217840a0c2203802d2635db0e4775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>ch</code> is an escape character.  <br /></td></tr>
<tr class="separator:ae4f217840a0c2203802d2635db0e4775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab800c304fbce812e2a4b309eb6c91030" id="r_ab800c304fbce812e2a4b309eb6c91030"><td class="memTemplParams" colspan="2">template&lt;typename Words &gt; </td></tr>
<tr class="memitem:ab800c304fbce812e2a4b309eb6c91030"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab800c304fbce812e2a4b309eb6c91030">removeQuotations</a> (Words const &amp;words) const</td></tr>
<tr class="memdesc:ab800c304fbce812e2a4b309eb6c91030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>words</code> with no quotation starts and ends.  <br /></td></tr>
<tr class="separator:ab800c304fbce812e2a4b309eb6c91030"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a97456628bb7fa9fbe5dff5de4c2580db" id="r_a97456628bb7fa9fbe5dff5de4c2580db"><td class="memItemLeft" align="right" valign="top">static std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a> (std::string const &amp;s)</td></tr>
<tr class="memdesc:a97456628bb7fa9fbe5dff5de4c2580db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::string_view</code> from an entire string <code>s</code>.  <br /></td></tr>
<tr class="separator:a97456628bb7fa9fbe5dff5de4c2580db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11253fc69ac22ca140e647511f200b1" id="r_ac11253fc69ac22ca140e647511f200b1"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:ac11253fc69ac22ca140e647511f200b1"><td class="memTemplItemLeft" align="right" valign="top">static std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac11253fc69ac22ca140e647511f200b1">make_view</a> (BIter b, EIter e)</td></tr>
<tr class="memdesc:ac11253fc69ac22ca140e647511f200b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::string_view</code> from two string iterators <code>b</code> and <code>e</code>.  <br /></td></tr>
<tr class="separator:ac11253fc69ac22ca140e647511f200b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2100f4bcaeaf4a5cc6181d9c533e6f64" id="r_a2100f4bcaeaf4a5cc6181d9c533e6f64"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="../../d9/d5f/structicarus_1_1ParsingToolkit_1_1CCTypeAdapter.html">CCTypeAdapter</a>&lt;&amp;std::isblank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a> {}</td></tr>
<tr class="memdesc:a2100f4bcaeaf4a5cc6181d9c533e6f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter for determining if a character is a blank (see <code>std::isblank()</code>).  <br /></td></tr>
<tr class="separator:a2100f4bcaeaf4a5cc6181d9c533e6f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523180de83def4934a514e53195233bd" id="r_a523180de83def4934a514e53195233bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a523180de83def4934a514e53195233bd">DefaultParameters</a></td></tr>
<tr class="separator:a523180de83def4934a514e53195233bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aeec514386dbfbf8e9ced24dcdccc764a" id="r_aeec514386dbfbf8e9ced24dcdccc764a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeec514386dbfbf8e9ced24dcdccc764a">adoptParams</a> (<a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a> <a class="el" href="#a18d4186db8f1859bab3cf1e8f30a2345">params</a>)</td></tr>
<tr class="memdesc:aeec514386dbfbf8e9ced24dcdccc764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the parameters and caches.  <br /></td></tr>
<tr class="separator:aeec514386dbfbf8e9ced24dcdccc764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2bceda651449f16763f91450d13f5d27" id="r_a2bceda651449f16763f91450d13f5d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bceda651449f16763f91450d13f5d27">fParams</a></td></tr>
<tr class="memdesc:a2bceda651449f16763f91450d13f5d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsing parameters.  <br /></td></tr>
<tr class="separator:a2bceda651449f16763f91450d13f5d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf582659e376b2550059557df8748f5e" id="r_acf582659e376b2550059557df8748f5e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf582659e376b2550059557df8748f5e">fQuoteStarts</a></td></tr>
<tr class="memdesc:acf582659e376b2550059557df8748f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start characters of all supported quotations.  <br /></td></tr>
<tr class="separator:acf582659e376b2550059557df8748f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tokenization</h2></td></tr>
<tr class="memitem:a86eb5c8203c50d57a3cee3924272ab6d" id="r_a86eb5c8203c50d57a3cee3924272ab6d"><td class="memTemplParams" colspan="2">template&lt;typename Delim &gt; </td></tr>
<tr class="memitem:a86eb5c8203c50d57a3cee3924272ab6d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string_view &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords</a> (std::string const &amp;s, Delim isDelimiter) const</td></tr>
<tr class="memdesc:a86eb5c8203c50d57a3cee3924272ab6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into words.  <br /></td></tr>
<tr class="separator:a86eb5c8203c50d57a3cee3924272ab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903e5da5e7eff0639b6cde04cee4159f" id="r_a903e5da5e7eff0639b6cde04cee4159f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a903e5da5e7eff0639b6cde04cee4159f">splitWords</a> (std::string const &amp;s) const</td></tr>
<tr class="memdesc:a903e5da5e7eff0639b6cde04cee4159f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper version of <code>splitWords(std::string const&amp;, Delim)</code>.  <br /></td></tr>
<tr class="separator:a903e5da5e7eff0639b6cde04cee4159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462458536292514ffb792314a55d4a25" id="r_a462458536292514ffb792314a55d4a25"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a462458536292514ffb792314a55d4a25"><td class="memTemplItemLeft" align="right" valign="top">Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a462458536292514ffb792314a55d4a25">findCommentWord</a> (Iter beginWord, Iter endWord) const</td></tr>
<tr class="memdesc:a462458536292514ffb792314a55d4a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first word starting with a comment marker.  <br /></td></tr>
<tr class="separator:a462458536292514ffb792314a55d4a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ce9cfdc4894f9852e4f52c97c43929" id="r_aa2ce9cfdc4894f9852e4f52c97c43929"><td class="memTemplParams" colspan="2">template&lt;typename WordType &gt; </td></tr>
<tr class="memitem:aa2ce9cfdc4894f9852e4f52c97c43929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2ce9cfdc4894f9852e4f52c97c43929">removeCommentLine</a> (std::vector&lt; WordType &gt; &amp;words) const</td></tr>
<tr class="memdesc:aa2ce9cfdc4894f9852e4f52c97c43929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the words from the one starting with a comment marker.  <br /></td></tr>
<tr class="separator:aa2ce9cfdc4894f9852e4f52c97c43929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1204805895fe677ef654f8a2371ee558" id="r_a1204805895fe677ef654f8a2371ee558"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string_view, <a class="el" href="#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1204805895fe677ef654f8a2371ee558">findQuotationStart</a> (std::string_view sv) const</td></tr>
<tr class="memdesc:a1204805895fe677ef654f8a2371ee558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the start of the next quotation in <code>sv</code>.  <br /></td></tr>
<tr class="separator:a1204805895fe677ef654f8a2371ee558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ea851382672ff5f1802ec0b65bf985" id="r_a32ea851382672ff5f1802ec0b65bf985"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32ea851382672ff5f1802ec0b65bf985">findQuotationEnd</a> (std::string_view sv, std::string const &amp;quotEnd) const</td></tr>
<tr class="memdesc:a32ea851382672ff5f1802ec0b65bf985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the quotation end in <code>sv</code>.  <br /></td></tr>
<tr class="separator:a32ea851382672ff5f1802ec0b65bf985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be9c81e6412b0b4887c85c55e41cda" id="r_a33be9c81e6412b0b4887c85c55e41cda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33be9c81e6412b0b4887c85c55e41cda">isQuotationUnclosed</a> (std::string_view sv) const</td></tr>
<tr class="memdesc:a33be9c81e6412b0b4887c85c55e41cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the sequence <code>sv</code> has unclosed quotation at its end.  <br /></td></tr>
<tr class="separator:a33be9c81e6412b0b4887c85c55e41cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b" id="r_ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b">findFirstUnescaped</a> (std::string_view sv, BIter beginKey, EIter endKey) const</td></tr>
<tr class="memdesc:ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in <code>sv</code>.  <br /></td></tr>
<tr class="separator:ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686954cef12121982a99543c506d0586" id="r_a686954cef12121982a99543c506d0586"><td class="memTemplParams" colspan="2">template&lt;typename Keys &gt; </td></tr>
<tr class="memitem:a686954cef12121982a99543c506d0586"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a686954cef12121982a99543c506d0586">findFirstUnescaped</a> (std::string_view sv, Keys const &amp;keys) const</td></tr>
<tr class="memdesc:a686954cef12121982a99543c506d0586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in <code>sv</code>.  <br /></td></tr>
<tr class="separator:a686954cef12121982a99543c506d0586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7bb5f693a86b3741e7e04638848080" id="r_a4c7bb5f693a86b3741e7e04638848080"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a4c7bb5f693a86b3741e7e04638848080"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c7bb5f693a86b3741e7e04638848080">findFirstUnescaped</a> (std::string_view sv, std::initializer_list&lt; Key &gt; keys) const</td></tr>
<tr class="memdesc:a4c7bb5f693a86b3741e7e04638848080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into words.  <br /></td></tr>
<tr class="separator:a4c7bb5f693a86b3741e7e04638848080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c90c81ad7c38315da145f9d915f24b" id="r_a14c90c81ad7c38315da145f9d915f24b"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:a14c90c81ad7c38315da145f9d915f24b"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14c90c81ad7c38315da145f9d915f24b">findFirstUnquoted</a> (std::string_view sv, BIter beginKey, EIter endKey) const</td></tr>
<tr class="memdesc:a14c90c81ad7c38315da145f9d915f24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in the unquoted part of <code>sv</code>.  <br /></td></tr>
<tr class="separator:a14c90c81ad7c38315da145f9d915f24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee786c093bdc0e1bc2a3330558ccd0b8" id="r_aee786c093bdc0e1bc2a3330558ccd0b8"><td class="memTemplParams" colspan="2">template&lt;typename Keys &gt; </td></tr>
<tr class="memitem:aee786c093bdc0e1bc2a3330558ccd0b8"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aee786c093bdc0e1bc2a3330558ccd0b8">findFirstUnquoted</a> (std::string_view sv, Keys const &amp;keys) const</td></tr>
<tr class="memdesc:aee786c093bdc0e1bc2a3330558ccd0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in the unquoted part of <code>sv</code>.  <br /></td></tr>
<tr class="separator:aee786c093bdc0e1bc2a3330558ccd0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827047526291f0f2a1360b6860d22612" id="r_a827047526291f0f2a1360b6860d22612"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a827047526291f0f2a1360b6860d22612"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a827047526291f0f2a1360b6860d22612">findFirstUnquoted</a> (std::string_view sv, std::initializer_list&lt; Key &gt; keys) const</td></tr>
<tr class="memdesc:a827047526291f0f2a1360b6860d22612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into words.  <br /></td></tr>
<tr class="separator:a827047526291f0f2a1360b6860d22612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a13ec3538d5983475ba3165ce4bae72" id="r_a2a13ec3538d5983475ba3165ce4bae72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t">SplitView_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a13ec3538d5983475ba3165ce4bae72">splitOn</a> (std::string_view sv, std::string_view sep)</td></tr>
<tr class="memdesc:a2a13ec3538d5983475ba3165ce4bae72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the view <code>sv</code> in three: before <code>sep</code>, <code>sep</code> and after <code>sep</code>.  <br /></td></tr>
<tr class="separator:a2a13ec3538d5983475ba3165ce4bae72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utilities for text parsing. </p>
<p>This "class" is a glorified namespace with some configuration inside.</p>
<h2>Quotation </h2>
<p>A quoted string is the content in between an opening quoting sequence and the matching closing sequence. Each sequence may be any string, including but not limited to a one-character long string. Escaping the first character of an opening or closing quotation string will turn it in common string data carrying no quotation meaning.</p>
<h2>Escaping rules </h2>
<p>Any single character following the escape character is "escaped". The escaped characters lose their standard function and are replaced by a substitute character. For example, escaping the first character of a opening quotation makes that a standard character. An escaped escape character is always replaced by the character itself, without its escape function. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00054">54</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="da/d61/structicarus_1_1ParsingToolkit_1_1Params__t" id="da/d61/structicarus_1_1ParsingToolkit_1_1Params__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">&#9670;&#160;</a></span>icarus::ParsingToolkit::Params_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct icarus::ParsingToolkit::Params_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>All parsing parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00066">66</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a611b5343feca4a0cfb6040d3b691a25f" name="a611b5343feca4a0cfb6040d3b691a25f"></a>string</td>
<td class="fieldname">
comment { &quot;#&quot; }</td>
<td class="fielddoc">
Word introducing a comment. </td></tr>
<tr><td class="fieldtype">
<a id="ac6ce4e274ab86089a463bbbf43d609b8" name="ac6ce4e274ab86089a463bbbf43d609b8"></a>char</td>
<td class="fieldname">
EOL { '\n' }</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aefba854f9d6536bcbe3b27193c0ed567" name="aefba854f9d6536bcbe3b27193c0ed567"></a>char</td>
<td class="fieldname">
escape { '\\' }</td>
<td class="fielddoc">
Escape character. </td></tr>
<tr><td class="fieldtype">
<a id="ae26d399098e4b368e706a839de9427a6" name="ae26d399098e4b368e706a839de9427a6"></a>vector&lt; <a class="el" href="#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> &gt;</td>
<td class="fieldname">
quotes</td>
<td class="fielddoc">
List of matching start and end of quote. </td></tr>
</table>

</div>
</div>
<a name="dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t" id="dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t">&#9670;&#160;</a></span>icarus::ParsingToolkit::SplitView_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct icarus::ParsingToolkit::SplitView_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Record of a split token: pre-separator, separator and post-separator. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00060">60</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a10f9a60f8e7c17c560d6b495ece0933b" name="a10f9a60f8e7c17c560d6b495ece0933b"></a>string_view</td>
<td class="fieldname">
post</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="acb8d2c162cc1e7415e8255fd7572a269" name="acb8d2c162cc1e7415e8255fd7572a269"></a>string_view</td>
<td class="fieldname">
pre</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a4af3bd79614e99a8b4e5de2e0a405a2e" name="a4af3bd79614e99a8b4e5de2e0a405a2e"></a>string_view</td>
<td class="fieldname">
sep</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9fae443451384bddeecef2c0237c5f27" name="a9fae443451384bddeecef2c0237c5f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae443451384bddeecef2c0237c5f27">&#9670;&#160;</a></span>QuotSpec_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9fae443451384bddeecef2c0237c5f27">icarus::ParsingToolkit::QuotSpec_t</a> = std::pair&lt;std::string, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specification of quotation: opening and closing. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00063">63</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c0771b23b03681072f28a87950c04e5" name="a0c0771b23b03681072f28a87950c04e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0771b23b03681072f28a87950c04e5">&#9670;&#160;</a></span>ParsingToolkit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icarus::ParsingToolkit::ParsingToolkit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default parsing parameters. </p>
<p>Creates a parser with the default parsing parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00100">100</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#aeec514386dbfbf8e9ced24dcdccc764a">adoptParams()</a>.</p>

</div>
</div>
<a id="a1c911af179a04d12b4da58e68be9d019" name="a1c911af179a04d12b4da58e68be9d019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c911af179a04d12b4da58e68be9d019">&#9670;&#160;</a></span>ParsingToolkit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icarus::ParsingToolkit::ParsingToolkit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a></td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a parser with the specified parsing parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00103">103</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#aeec514386dbfbf8e9ced24dcdccc764a">adoptParams()</a>, and <a class="el" href="#a18d4186db8f1859bab3cf1e8f30a2345">params()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeec514386dbfbf8e9ced24dcdccc764a" name="aeec514386dbfbf8e9ced24dcdccc764a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec514386dbfbf8e9ced24dcdccc764a">&#9670;&#160;</a></span>adoptParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::ParsingToolkit::adoptParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a></td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the parameters and caches. </p>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00220">220</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a0c0771b23b03681072f28a87950c04e5">ParsingToolkit()</a>, and <a class="el" href="#a1c911af179a04d12b4da58e68be9d019">ParsingToolkit()</a>.</p>

</div>
</div>
<a id="a462458536292514ffb792314a55d4a25" name="a462458536292514ffb792314a55d4a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462458536292514ffb792314a55d4a25">&#9670;&#160;</a></span>findCommentWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iter icarus::ParsingToolkit::findCommentWord </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>beginWord</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>endWord</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first word starting with a comment marker. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>type of iterator to the words </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginWord</td><td>iterator to the first word to consider </td></tr>
    <tr><td class="paramname">endWord</td><td>iterator past the lasy word to consider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the comment word, or <code>endWord</code> if not found</dd></dl>
<p>The original list is modified, the word starting with a comment marker and all the following ones are removed. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00748">748</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#aa2ce9cfdc4894f9852e4f52c97c43929">removeCommentLine()</a>.</p>

</div>
</div>
<a id="ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b" name="ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d9bf92bc2d99aa7ec94a7b6b6f6e5b">&#9670;&#160;</a></span>findFirstUnescaped() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnescaped </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIter</td>          <td class="paramname"><span class="paramname"><em>beginKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter</td>          <td class="paramname"><span class="paramname"><em>endKey</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the key found within <code>sv</code>, empty if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first). The first character of the key must not be escaped. Escaped characters in the key are not supported.</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>.</p>
<p>The quoting in <code>sv</code> is ignored. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00633">633</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a686954cef12121982a99543c506d0586" name="a686954cef12121982a99543c506d0586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686954cef12121982a99543c506d0586">&#9670;&#160;</a></span>findFirstUnescaped() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Keys &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnescaped </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Keys const &amp;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the key found within <code>sv</code>, empty if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first). The first character of the key must not be escaped. Escaped characters in the key are not supported.</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>.</p>
<p>The quoting in <code>sv</code> is ignored. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00666">666</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a4c7bb5f693a86b3741e7e04638848080" name="a4c7bb5f693a86b3741e7e04638848080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7bb5f693a86b3741e7e04638848080">&#9670;&#160;</a></span>findFirstUnescaped() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnescaped </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Key &gt;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into words. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Delim</td><td>type of delimiter functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string to be split </td></tr>
    <tr><td class="paramname">isDelimiter</td><td>(default: <code>isblank()</code>) determines if a character is a word delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of views, one per word</dd></dl>
<p>The splitter algorithm defines a word separator as a sequence of one or more unescaped, unquoted delimiter characters, where a delimiter is a character <code>ch</code> for which <code>isDelimiter(ch)</code> is <code>true</code>.</p>
<p>Note that this function does not change the content of the data, and in particular it does not remove escaping nor quoting (although it interprets both).</p>
<p>A character used as delimiter can appear in a word only if escaped or within quotation. Contiguous non-delimiter elements of a string, including quoted strings, belong to the same word (for example, <code>a" and "b</code> is a single word when delimitation is by blank characters). An empty word can be introduced only in quotations (e.g. <code>""</code>).</p>
<p>The <code>Delim</code> type is a functor so that <code>isDelimiter(ch)</code> returns something convertible to <code>bool</code>, <code>true</code> if the <code>ch</code> character should be considered a delimiter. Note that no context is provided for the answer, so the use of each character as delimiter is fixed, and modified only by the hard-coded quotation and escaping rules.</p>
<p>The first characters of quotation starts and the escape characters must not be classified as delimiters, or the algorithm will give wrong results. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00676">676</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a14c90c81ad7c38315da145f9d915f24b" name="a14c90c81ad7c38315da145f9d915f24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c90c81ad7c38315da145f9d915f24b">&#9670;&#160;</a></span>findFirstUnquoted() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnquoted </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIter</td>          <td class="paramname"><span class="paramname"><em>beginKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter</td>          <td class="paramname"><span class="paramname"><em>endKey</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in the unquoted part of <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the view pointing to the key in <code>sv</code>, or empty to its end if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first).</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00683">683</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="aee786c093bdc0e1bc2a3330558ccd0b8" name="aee786c093bdc0e1bc2a3330558ccd0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee786c093bdc0e1bc2a3330558ccd0b8">&#9670;&#160;</a></span>findFirstUnquoted() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Keys &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnquoted </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Keys const &amp;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in the unquoted part of <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the view pointing to the key in <code>sv</code>, or empty to its end if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first).</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00731">731</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a827047526291f0f2a1360b6860d22612" name="a827047526291f0f2a1360b6860d22612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827047526291f0f2a1360b6860d22612">&#9670;&#160;</a></span>findFirstUnquoted() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnquoted </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Key &gt;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into words. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Delim</td><td>type of delimiter functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string to be split </td></tr>
    <tr><td class="paramname">isDelimiter</td><td>(default: <code>isblank()</code>) determines if a character is a word delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of views, one per word</dd></dl>
<p>The splitter algorithm defines a word separator as a sequence of one or more unescaped, unquoted delimiter characters, where a delimiter is a character <code>ch</code> for which <code>isDelimiter(ch)</code> is <code>true</code>.</p>
<p>Note that this function does not change the content of the data, and in particular it does not remove escaping nor quoting (although it interprets both).</p>
<p>A character used as delimiter can appear in a word only if escaped or within quotation. Contiguous non-delimiter elements of a string, including quoted strings, belong to the same word (for example, <code>a" and "b</code> is a single word when delimitation is by blank characters). An empty word can be introduced only in quotations (e.g. <code>""</code>).</p>
<p>The <code>Delim</code> type is a functor so that <code>isDelimiter(ch)</code> returns something convertible to <code>bool</code>, <code>true</code> if the <code>ch</code> character should be considered a delimiter. Note that no context is provided for the answer, so the use of each character as delimiter is fixed, and modified only by the hard-coded quotation and escaping rules.</p>
<p>The first characters of quotation starts and the escape characters must not be classified as delimiters, or the algorithm will give wrong results. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00741">741</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a6a5d545ee1dad7786e27f8240e85f64e" name="a6a5d545ee1dad7786e27f8240e85f64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5d545ee1dad7786e27f8240e85f64e">&#9670;&#160;</a></span>findNextBlank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::const_iterator icarus::ParsingToolkit::findNextBlank </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <code>findNextCharacter(std::string_view, Sel)</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00405">405</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a2b3a27d4a423ae42c7e98c182b4154be">findNextCharacter()</a>, and <a class="el" href="#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a>.</p>

</div>
</div>
<a id="a2b3a27d4a423ae42c7e98c182b4154be" name="a2b3a27d4a423ae42c7e98c182b4154be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3a27d4a423ae42c7e98c182b4154be">&#9670;&#160;</a></span>findNextCharacter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::const_iterator icarus::ParsingToolkit::findNextCharacter </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sel</td>          <td class="paramname"><span class="paramname"><em>select</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next character satisfying the specified criterion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sel</td><td>type of functor determining which character to consider blank </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>view of the string to be parsed </td></tr>
    <tr><td class="paramname">select</td><td>functor determining which character(s) to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first character, <code>s.end()</code> if none</dd></dl>
<p>By default, the selected character is a blank character <code>ch</code>, which has <code>std::isblank(ch)</code> <code>true</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00777">777</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a6a5d545ee1dad7786e27f8240e85f64e">findNextBlank()</a>, and <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="a32ea851382672ff5f1802ec0b65bf985" name="a32ea851382672ff5f1802ec0b65bf985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ea851382672ff5f1802ec0b65bf985">&#9670;&#160;</a></span>findQuotationEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findQuotationEnd </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>quotEnd</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the quotation end in <code>sv</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>the buffer to look the quotation end into </td></tr>
    <tr><td class="paramname">quotEnd</td><td>the quotation end to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of <code>sv</code> from the quotation end, included, empty if not found</dd></dl>
<p>Note that <code>sv</code> should not include the quotation start. </p>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00106">106</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="a1204805895fe677ef654f8a2371ee558" name="a1204805895fe677ef654f8a2371ee558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1204805895fe677ef654f8a2371ee558">&#9670;&#160;</a></span>findQuotationStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::ParsingToolkit::findQuotationStart </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the start of the next quotation in <code>sv</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>the buffer to look the quotation start into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a subview of <code>sv</code> starting from the quotation found, empty if none </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00066">66</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="adafe2b9c538e8e3571523e86534f12bf" name="adafe2b9c538e8e3571523e86534f12bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafe2b9c538e8e3571523e86534f12bf">&#9670;&#160;</a></span>isCharacterEscaped() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isCharacterEscaped </td>
          <td>(</td>
          <td class="paramtype">BIter</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIter</td>          <td class="paramname"><span class="paramname"><em>itCh</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the character pointed by <code>itCh</code> is escaped or not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to the beginning of the string </td></tr>
    <tr><td class="paramname">itCh</td><td>iterator to the character to be investigated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether there is an unescaped escape character before <code>itCh</code></dd></dl>
<p>Note that <code>itCh</code> may be a end iterator (for an empty string, the result is <code>false</code>). </p>

<p class="reference">Referenced by <a class="el" href="#a4c34c1b8eec9fd1f6a66f88936e07c98">readMultiline()</a>.</p>

</div>
</div>
<a id="aacdc2cfe194a1a95b3e58d45fdb47c72" name="aacdc2cfe194a1a95b3e58d45fdb47c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdc2cfe194a1a95b3e58d45fdb47c72">&#9670;&#160;</a></span>isCharacterEscaped() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isCharacterEscaped </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>itCh</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00760">760</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a2649b2c20a14a6958ab20d66585332cd" name="a2649b2c20a14a6958ab20d66585332cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2649b2c20a14a6958ab20d66585332cd">&#9670;&#160;</a></span>isEscape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isEscape </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>ch</code> is an escape character. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00375">375</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#aefba854f9d6536bcbe3b27193c0ed567">icarus::ParsingToolkit::Params_t::escape</a>, and <a class="el" href="#a2bceda651449f16763f91450d13f5d27">fParams</a>.</p>

</div>
</div>
<a id="a33be9c81e6412b0b4887c85c55e41cda" name="a33be9c81e6412b0b4887c85c55e41cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33be9c81e6412b0b4887c85c55e41cda">&#9670;&#160;</a></span>isQuotationUnclosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isQuotationUnclosed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the sequence <code>sv</code> has unclosed quotation at its end. </p>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00128">128</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a4c34c1b8eec9fd1f6a66f88936e07c98">readMultiline()</a>.</p>

</div>
</div>
<a id="ac11253fc69ac22ca140e647511f200b1" name="ac11253fc69ac22ca140e647511f200b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11253fc69ac22ca140e647511f200b1">&#9670;&#160;</a></span>make_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string_view icarus::ParsingToolkit::make_view </td>
          <td>(</td>
          <td class="paramtype">BIter</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code>std::string_view</code> from two string iterators <code>b</code> and <code>e</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00515">515</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a97456628bb7fa9fbe5dff5de4c2580db" name="a97456628bb7fa9fbe5dff5de4c2580db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97456628bb7fa9fbe5dff5de4c2580db">&#9670;&#160;</a></span>make_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string_view icarus::ParsingToolkit::make_view </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code>std::string_view</code> from an entire string <code>s</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00510">510</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a97456628bb7fa9fbe5dff5de4c2580db">make_view()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a97456628bb7fa9fbe5dff5de4c2580db">make_view()</a>, <a class="el" href="#a4c34c1b8eec9fd1f6a66f88936e07c98">readMultiline()</a>, and <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="a18d4186db8f1859bab3cf1e8f30a2345" name="a18d4186db8f1859bab3cf1e8f30a2345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d4186db8f1859bab3cf1e8f30a2345">&#9670;&#160;</a></span>params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a> const  &amp; icarus::ParsingToolkit::params </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current parameters of parsing. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00111">111</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a2bceda651449f16763f91450d13f5d27">fParams</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a1c911af179a04d12b4da58e68be9d019">ParsingToolkit()</a>.</p>

</div>
</div>
<a id="a4c34c1b8eec9fd1f6a66f88936e07c98" name="a4c34c1b8eec9fd1f6a66f88936e07c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c34c1b8eec9fd1f6a66f88936e07c98">&#9670;&#160;</a></span>readMultiline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, unsigned int &gt; icarus::ParsingToolkit::readMultiline </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a single line of text from the input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string read, and the number of lines read </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d4/dce/structicarus_1_1ParsingToolkit_1_1Error.html">Error</a></td><td>on fatal parsing errors</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads entire lines from <code>in</code>, where a line is defined as in <code>std::getline()</code>. If the line ends with an unescaped escape character, another line is read and appended (the escape character is dropped). The return value is the merged string with no end-of-line characters, and the number of lines read. If there is no string to be read, it returns an empty string and <code>0U</code>.</p>
<h3>Special behaviour</h3>
<ul>
<li>If the line ends while a quotation is still open, the next line is also merged, and the line break is kept; to merge quoted lines without preserving the line break character, end the quote on the first line, immediately break the line escaping it, and then next line should immediately start with opening a quotation.</li>
<li>If the line ends while a quotation is still open, it is a parsing error to have the line break character escaped (an exception will be thrown) merged, and the line break is kept.</li>
<li>If the file ends while a quotation is still open, the line is preserved as such. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00026">26</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

<p class="reference">References <a class="el" href="#a2bceda651449f16763f91450d13f5d27">fParams</a>, <a class="el" href="#adafe2b9c538e8e3571523e86534f12bf">isCharacterEscaped()</a>, <a class="el" href="#a33be9c81e6412b0b4887c85c55e41cda">isQuotationUnclosed()</a>, and <a class="el" href="#a97456628bb7fa9fbe5dff5de4c2580db">make_view()</a>.</p>

</div>
</div>
<a id="aa2ce9cfdc4894f9852e4f52c97c43929" name="aa2ce9cfdc4894f9852e4f52c97c43929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ce9cfdc4894f9852e4f52c97c43929">&#9670;&#160;</a></span>removeCommentLine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::ParsingToolkit::removeCommentLine </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; WordType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>words</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the words from the one starting with a comment marker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>list of words</td></tr>
  </table>
  </dd>
</dl>
<p>The original list is modified, the word starting with a comment marker and all the following ones are removed. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00216">216</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a462458536292514ffb792314a55d4a25">findCommentWord()</a>.</p>

</div>
</div>
<a id="a39c2e4d6f3dc6a9892c1246d87aec9ec" name="a39c2e4d6f3dc6a9892c1246d87aec9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c2e4d6f3dc6a9892c1246d87aec9ec">&#9670;&#160;</a></span>removeEscapes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Words &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; icarus::ParsingToolkit::removeEscapes </td>
          <td>(</td>
          <td class="paramtype">Words const &amp;</td>          <td class="paramname"><span class="paramname"><em>words</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>words</code> with all escape characters removed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Words</td><td>type of list of words </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>the list of words to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of words without escaping </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>removeEscapes(std::string)</code></dd></dl>
<p>The escaping is removed from each of the <code>words</code> in the list, which are treated as independent. See <code>removeEscapes(std::string)</code> for the details. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00809">809</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="ab800c304fbce812e2a4b309eb6c91030" name="ab800c304fbce812e2a4b309eb6c91030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab800c304fbce812e2a4b309eb6c91030">&#9670;&#160;</a></span>removeQuotations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Words &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; icarus::ParsingToolkit::removeQuotations </td>
          <td>(</td>
          <td class="paramtype">Words const &amp;</td>          <td class="paramname"><span class="paramname"><em>words</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>words</code> with no quotation starts and ends. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Words</td><td>type of list of words </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>the list of words to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of words without quotations </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>removeQuotations(std::string)</code></dd></dl>
<p>The substitution is applied on each of the <code>words</code> in the list, which are treated as independent. See <code>removeQuotations(std::string)</code> for the details. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00822">822</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a4d20ba31cc977d0387762f2bff248388" name="a4d20ba31cc977d0387762f2bff248388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d20ba31cc977d0387762f2bff248388">&#9670;&#160;</a></span>removeTrailingBlanks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::removeTrailingBlanks </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumes the blank characters a the beginning of <code>s</code>. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#aea0c8bcc0d9559e642a5beeeec9d840b" title="Consumes the blank characters a the beginning of s.">removeTrailingCharacters()</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00422">422</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a>, and <a class="el" href="#aea0c8bcc0d9559e642a5beeeec9d840b">removeTrailingCharacters()</a>.</p>

</div>
</div>
<a id="aea0c8bcc0d9559e642a5beeeec9d840b" name="aea0c8bcc0d9559e642a5beeeec9d840b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0c8bcc0d9559e642a5beeeec9d840b">&#9670;&#160;</a></span>removeTrailingCharacters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::removeTrailingCharacters </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CType</td>          <td class="paramname"><span class="paramname"><em>charType</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes the blank characters a the beginning of <code>s</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CType</td><td>type of functor determining which type of character to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>view of the string to be parsed </td></tr>
    <tr><td class="paramname">charType</td><td>functor determining which characters to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of <code>s</code> starting after its trailing <code>charType</code> characters </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a4d20ba31cc977d0387762f2bff248388" title="Consumes the blank characters a the beginning of s.">removeTrailingBlanks()</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00793">793</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a4d20ba31cc977d0387762f2bff248388">removeTrailingBlanks()</a>, and <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="aa88acdad6a0258dda93b420fb12ba0aa" name="aa88acdad6a0258dda93b420fb12ba0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88acdad6a0258dda93b420fb12ba0aa">&#9670;&#160;</a></span>removeWordEscapes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordEscapes </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>ch</code> is an escape character. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00449">449</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#aac5888a2857106d9d377334db736070a">removeWordEscapes()</a>.</p>

</div>
</div>
<a id="aac5888a2857106d9d377334db736070a" name="aac5888a2857106d9d377334db736070a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5888a2857106d9d377334db736070a">&#9670;&#160;</a></span>removeWordEscapes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordEscapes </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>w</code> with all escape characters removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>the string to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>w</code> without escaping </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a39c2e4d6f3dc6a9892c1246d87aec9ec" title="Returns a copy of words with all escape characters removed.">removeEscapes</a>(Word const&amp;)</code></dd></dl>
<p>The escaping scheme that is applied is just to remove the escape character (no replacement table supported here). An unescaped escape character at the end of the string will not be removed.</p>
<p>It is recommended that this be done as the last step of the parsing, since it changes the meaning of the parsing elements like quotations, comments etc.</p>
<p>Note that applying <code><a class="el" href="#a39c2e4d6f3dc6a9892c1246d87aec9ec" title="Returns a copy of words with all escape characters removed.">removeEscapes()</a></code> more than once will keep removing characters that in the earlier passes were not considered escapes (for example, four escape characters become two in the first pass, one in the second and disappear in the following passes). </p>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00158">158</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#aa88acdad6a0258dda93b420fb12ba0aa">removeWordEscapes()</a>, and <a class="el" href="#ad00075aa46063a35041b70a6483f4945">removeWordEscapes()</a>.</p>

</div>
</div>
<a id="ad00075aa46063a35041b70a6483f4945" name="ad00075aa46063a35041b70a6483f4945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00075aa46063a35041b70a6483f4945">&#9670;&#160;</a></span>removeWordEscapes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordEscapes </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>ch</code> is an escape character. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00447">447</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#aac5888a2857106d9d377334db736070a">removeWordEscapes()</a>.</p>

</div>
</div>
<a id="ae4f217840a0c2203802d2635db0e4775" name="ae4f217840a0c2203802d2635db0e4775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f217840a0c2203802d2635db0e4775">&#9670;&#160;</a></span>removeWordQuotations() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordQuotations </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>ch</code> is an escape character. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00487">487</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a74a56eace9f2404e51d7bdd8289770af">removeWordQuotations()</a>.</p>

</div>
</div>
<a id="a74a56eace9f2404e51d7bdd8289770af" name="a74a56eace9f2404e51d7bdd8289770af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a56eace9f2404e51d7bdd8289770af">&#9670;&#160;</a></span>removeWordQuotations() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordQuotations </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>w</code> with no quotation starts and ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>the string to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the word without quotations </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ab800c304fbce812e2a4b309eb6c91030" title="Returns a copy of words with no quotation starts and ends.">removeQuotations</a>(Words const&amp;)</code></dd></dl>
<p>Escaping is still honored (if present).</p>
<p>Note that applying <code>removeQuotations</code> more than once will keep removing quotation markings that in the earlier passes were not considered such (for example, &lsquo;a1 &lt;&lt; "b1 &lt;&lt; 'c1 &lt;&lt; " or " &lt;&lt; c2&amp;rsquo; &lt;&lt; b2" &lt;&lt; a2<code>will become first </code>a1 &lt;&lt; b1 &lt;&lt; 'c1 &lt;&lt; or &lt;&lt; c2' &lt;&lt; b2 &lt;&lt; a2<code>, and eventually </code>a1 &lt;&lt; b1 &lt;&lt; c1 &lt;&lt; or &lt;&lt; c2 &lt;&lt; b2 &lt;&lt; a2`). </p>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00176">176</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ae4f217840a0c2203802d2635db0e4775">removeWordQuotations()</a>, and <a class="el" href="#aca43c92fcc028a442a6ced5c0245e9d3">removeWordQuotations()</a>.</p>

</div>
</div>
<a id="aca43c92fcc028a442a6ced5c0245e9d3" name="aca43c92fcc028a442a6ced5c0245e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca43c92fcc028a442a6ced5c0245e9d3">&#9670;&#160;</a></span>removeWordQuotations() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordQuotations </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>ch</code> is an escape character. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00485">485</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a74a56eace9f2404e51d7bdd8289770af">removeWordQuotations()</a>.</p>

</div>
</div>
<a id="a2a13ec3538d5983475ba3165ce4bae72" name="a2a13ec3538d5983475ba3165ce4bae72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a13ec3538d5983475ba3165ce4bae72">&#9670;&#160;</a></span>splitOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::ParsingToolkit::splitOn </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the view <code>sv</code> in three: before <code>sep</code>, <code>sep</code> and after <code>sep</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>view of the string to split </td></tr>
    <tr><td class="paramname">sep</td><td>a subview of <code>sv</code> to split at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="#dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t" title="Record of a split token: pre-separator, separator and post-separator.">SplitView_t</a></code> object with the three parts split, empty if needed</dd></dl>
<p>The view <code>sep</code> is required to be a subview of <code>sv</code>: it's not enough for it to have as content a substring of <code>sv</code>. For example, <code>splitOn("a:1", ":")</code> will not work, because the string <code>"a:1"</code> does not share data in memory with <code>":"</code>.</p>
<p>Even if <code>sep</code> is empty, it's still required to point with both <code>begin()</code> and <code>end()</code> within <code>sv</code>, and <code>sv</code> will be split according to that point. </p>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00149">149</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>

</div>
</div>
<a id="a903e5da5e7eff0639b6cde04cee4159f" name="a903e5da5e7eff0639b6cde04cee4159f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903e5da5e7eff0639b6cde04cee4159f">&#9670;&#160;</a></span>splitWords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string_view &gt; icarus::ParsingToolkit::splitWords </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper version of <code>splitWords(std::string const&amp;, Delim)</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00190">190</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a>, and <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="a86eb5c8203c50d57a3cee3924272ab6d" name="a86eb5c8203c50d57a3cee3924272ab6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86eb5c8203c50d57a3cee3924272ab6d">&#9670;&#160;</a></span>splitWords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Delim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string_view &gt; icarus::ParsingToolkit::splitWords </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Delim</td>          <td class="paramname"><span class="paramname"><em>isDelimiter</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into words. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Delim</td><td>type of delimiter functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string to be split </td></tr>
    <tr><td class="paramname">isDelimiter</td><td>(default: <code>isblank()</code>) determines if a character is a word delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of views, one per word</dd></dl>
<p>The splitter algorithm defines a word separator as a sequence of one or more unescaped, unquoted delimiter characters, where a delimiter is a character <code>ch</code> for which <code>isDelimiter(ch)</code> is <code>true</code>.</p>
<p>Note that this function does not change the content of the data, and in particular it does not remove escaping nor quoting (although it interprets both).</p>
<p>A character used as delimiter can appear in a word only if escaped or within quotation. Contiguous non-delimiter elements of a string, including quoted strings, belong to the same word (for example, <code>a" and "b</code> is a single word when delimitation is by blank characters). An empty word can be introduced only in quotations (e.g. <code>""</code>).</p>
<p>The <code>Delim</code> type is a functor so that <code>isDelimiter(ch)</code> returns something convertible to <code>bool</code>, <code>true</code> if the <code>ch</code> character should be considered a delimiter. Note that no context is provided for the answer, so the use of each character as delimiter is fixed, and modified only by the hard-coded quotation and escaping rules.</p>
<p>The first characters of quotation starts and the escape characters must not be classified as delimiters, or the algorithm will give wrong results. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00544">544</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">References <a class="el" href="#aefba854f9d6536bcbe3b27193c0ed567">icarus::ParsingToolkit::Params_t::escape</a>, <a class="el" href="#a2b3a27d4a423ae42c7e98c182b4154be">findNextCharacter()</a>, <a class="el" href="#a32ea851382672ff5f1802ec0b65bf985">findQuotationEnd()</a>, <a class="el" href="#a1204805895fe677ef654f8a2371ee558">findQuotationStart()</a>, <a class="el" href="#a2bceda651449f16763f91450d13f5d27">fParams</a>, <a class="el" href="#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>, <a class="el" href="#a97456628bb7fa9fbe5dff5de4c2580db">make_view()</a>, and <a class="el" href="#aea0c8bcc0d9559e642a5beeeec9d840b">removeTrailingCharacters()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a903e5da5e7eff0639b6cde04cee4159f">splitWords()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a523180de83def4934a514e53195233bd" name="a523180de83def4934a514e53195233bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523180de83def4934a514e53195233bd">&#9670;&#160;</a></span>DefaultParameters</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">icarus::ParsingToolkit::Params_t</a> const icarus::ParsingToolkit::DefaultParameters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00097">97</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a id="a2bceda651449f16763f91450d13f5d27" name="a2bceda651449f16763f91450d13f5d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bceda651449f16763f91450d13f5d27">&#9670;&#160;</a></span>fParams</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#da/d61/structicarus_1_1ParsingToolkit_1_1Params__t">Params_t</a> icarus::ParsingToolkit::fParams</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parsing parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00519">519</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a2649b2c20a14a6958ab20d66585332cd">isEscape()</a>, <a class="el" href="#a18d4186db8f1859bab3cf1e8f30a2345">params()</a>, <a class="el" href="#a4c34c1b8eec9fd1f6a66f88936e07c98">readMultiline()</a>, and <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="acf582659e376b2550059557df8748f5e" name="acf582659e376b2550059557df8748f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf582659e376b2550059557df8748f5e">&#9670;&#160;</a></span>fQuoteStarts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::fQuoteStarts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start characters of all supported quotations. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00524">524</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a86eb5c8203c50d57a3cee3924272ab6d">splitWords()</a>.</p>

</div>
</div>
<a id="a2100f4bcaeaf4a5cc6181d9c533e6f64" name="a2100f4bcaeaf4a5cc6181d9c533e6f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2100f4bcaeaf4a5cc6181d9c533e6f64">&#9670;&#160;</a></span>isBlank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5f/structicarus_1_1ParsingToolkit_1_1CCTypeAdapter.html">CCTypeAdapter</a>&lt;&amp;std::isblank&gt; icarus::ParsingToolkit::isBlank {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapter for determining if a character is a blank (see <code>std::isblank()</code>). </p>

<p class="definition">Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00092">92</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a6a5d545ee1dad7786e27f8240e85f64e">findNextBlank()</a>, <a class="el" href="#a4d20ba31cc977d0387762f2bff248388">removeTrailingBlanks()</a>, and <a class="el" href="#a903e5da5e7eff0639b6cde04cee4159f">splitWords()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>icaruscode/icaruscode/PMT/Algorithms/<a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a></li>
<li>icaruscode/icaruscode/PMT/Algorithms/<a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
