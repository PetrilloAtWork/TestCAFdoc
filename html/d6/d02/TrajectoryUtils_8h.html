<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAF format: icaruscode/icaruscode/Utilities/TrajectoryUtils.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/TeX/AMSmath','[tex]/TeX/AMSsymbols']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','TeX/AMSmath','TeX/AMSsymbols']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CAF format<span id="projectnumber">&#160;${SBNANAOBJ_VERSION}</span>
   </div>
   <div id="projectbrief">Simulation, reconstruction and analysis software for the ICARUS experiment.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_3bfe4976819e8434ce603ce37432c4f4.html">icaruscode</a></li><li class="navelem"><a class="el" href="../../dir_dd542699a33b65b3e6b0c52d22a2f906.html">icaruscode</a></li><li class="navelem"><a class="el" href="../../dir_da77bb444eb09191e9924c470ade0c3e.html">Utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">TrajectoryUtils.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Algorithms dealing with a trajectory as a sequence of 3D points.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;larcorealg/Geometry/geo_vectors_utils.h&quot;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
</div>
<p><a href="../../d6/d02/TrajectoryUtils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d01/structutil_1_1PathPointInfo__t.html">util::PathPointInfo_t&lt; Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data returned by <code><a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10" title="Returns information to identify the middle of the specified path.">findMiddlePointInPath()</a></code>.  <a href="../../d6/d01/structutil_1_1PathPointInfo__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6632dd48af20f7a5ac4bcea66724fb10" id="r_a6632dd48af20f7a5ac4bcea66724fb10"><td class="memTemplParams" colspan="2">template&lt;typename FIter , typename LIter &gt; </td></tr>
<tr class="memitem:a6632dd48af20f7a5ac4bcea66724fb10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d01/structutil_1_1PathPointInfo__t.html">PathPointInfo_t</a>&lt; FIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath</a> (FIter itFirst, LIter itLast, double relTarget=0.5)</td></tr>
<tr class="memdesc:a6632dd48af20f7a5ac4bcea66724fb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information to identify the middle of the specified path.  <br /></td></tr>
<tr class="separator:a6632dd48af20f7a5ac4bcea66724fb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca0c6bc1f82d56c58d11873336ff0ab" id="r_a9ca0c6bc1f82d56c58d11873336ff0ab"><td class="memTemplParams" colspan="2">template&lt;typename FIter , typename LIter &gt; </td></tr>
<tr class="memitem:a9ca0c6bc1f82d56c58d11873336ff0ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ca0c6bc1f82d56c58d11873336ff0ab">util::pathMiddlePoint</a> (FIter itFirst, LIter itLast, double relTarget=0.5)</td></tr>
<tr class="memdesc:a9ca0c6bc1f82d56c58d11873336ff0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometric point in the middle of the specified path.  <br /></td></tr>
<tr class="separator:a9ca0c6bc1f82d56c58d11873336ff0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8facb90d2f47a70dcf14ef46b165646" id="r_aa8facb90d2f47a70dcf14ef46b165646"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:aa8facb90d2f47a70dcf14ef46b165646"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8facb90d2f47a70dcf14ef46b165646">util::pathLength</a> (BIter begin, EIter end)</td></tr>
<tr class="memdesc:aa8facb90d2f47a70dcf14ef46b165646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total length of the specified path.  <br /></td></tr>
<tr class="separator:aa8facb90d2f47a70dcf14ef46b165646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686e20e8e75c4ec003ef382ead5f1c4b" id="r_a686e20e8e75c4ec003ef382ead5f1c4b"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:a686e20e8e75c4ec003ef382ead5f1c4b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a686e20e8e75c4ec003ef382ead5f1c4b">util::partialPathLengths</a> (BIter begin, EIter end)</td></tr>
<tr class="memdesc:a686e20e8e75c4ec003ef382ead5f1c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequences of partial lengths for the specified path.  <br /></td></tr>
<tr class="separator:a686e20e8e75c4ec003ef382ead5f1c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa9260deeb599367302642a39a3b5b5" id="r_adaa9260deeb599367302642a39a3b5b5"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename SideFunc &gt; </td></tr>
<tr class="memitem:adaa9260deeb599367302642a39a3b5b5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Iter, Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adaa9260deeb599367302642a39a3b5b5">util::findCrossingSegment</a> (Iter begin, Iter end, SideFunc sideOf)</td></tr>
<tr class="memdesc:adaa9260deeb599367302642a39a3b5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a path segment with ends on different sides than path ends.  <br /></td></tr>
<tr class="separator:adaa9260deeb599367302642a39a3b5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Algorithms dealing with a trajectory as a sequence of 3D points. </p>
<dl class="section author"><dt>Author</dt><dd>Gianluca Petrillo (<a href="mailto:petrillo@slac.stanford.edu">petrillo@slac.stanford.edu</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>July 26, 2022</dd></dl>
<p>This is a header-only library.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/d00/todo.html#_todo000007">Todo</a></b></dt><dd>Move this file into <code>icarusalg/Utilities</code>. </dd></dl>

<p class="definition">Definition in file <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html">TrajectoryUtils.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="adaa9260deeb599367302642a39a3b5b5" name="adaa9260deeb599367302642a39a3b5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa9260deeb599367302642a39a3b5b5">&#9670;&#160;</a></span>findCrossingSegment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename SideFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Iter, Iter &gt; util::findCrossingSegment </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SideFunc</td>          <td class="paramname"><span class="paramname"><em>sideOf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a path segment with ends on different sides than path ends. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>type of iterator to the points in the path </td></tr>
    <tr><td class="paramname">SideFunc</td><td>type of functor returning the side of a point </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to the first point of the path </td></tr>
    <tr><td class="paramname">end</td><td>iterator past the last point of the path </td></tr>
    <tr><td class="paramname">sideOf</td><td>functor returning the side of the point in argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of iterators pointing to the points found, <code>{ end, end }</code> if the path does not change side at all</dd></dl>
<p>The path is defined as a sequence of positions of arbitrary types. The functor <code>sideOf</code> takes as argument one such position, and returns an also arbitrary value representing the side of that position. This algorithm returns a pair with the first point where the side changes, and the point after the last side change. The two points match only if there is no side change at all (in which case a pair with two <code>end</code> iterators is returned). The two returned iterators are adjacent only if there is only one change of side.</p>
<p>Note that this algorithm is effectively not specific to a space path but it's rather a generic classification algorithm: given an ordered sequence, it finds the first and the last change of class.</p>
<h2>Requirements </h2>
<ul>
<li><code>Iter</code> must be a bidirectional operator (ask if this is too restrictive)</li>
<li><code>SideFunc</code> must support a call like. <code>Side SideFunc::operator() (Iter::value_type) const</code>, i.e. must accept as argument the position pointed by an iterator of type <code>Iter</code> and return an arbitrary <code>Side</code> value.</li>
<li><code>Side</code> type (returned by <code>sideOf</code>) must support <code>operator!= (Side, Side)</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html#l00454">454</a> of file <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html">TrajectoryUtils.h</a>.</p>

<p class="reference">References <a class="el" href="#adaa9260deeb599367302642a39a3b5b5">util::findCrossingSegment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#adaa9260deeb599367302642a39a3b5b5">util::findCrossingSegment()</a>, and <a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath()</a>.</p>

</div>
</div>
<a id="a6632dd48af20f7a5ac4bcea66724fb10" name="a6632dd48af20f7a5ac4bcea66724fb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6632dd48af20f7a5ac4bcea66724fb10">&#9670;&#160;</a></span>findMiddlePointInPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FIter , typename LIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PathPointInfo_t&lt; FIter &gt; util::findMiddlePointInPath </td>
          <td>(</td>
          <td class="paramtype">FIter</td>          <td class="paramname"><span class="paramname"><em>itFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LIter</td>          <td class="paramname"><span class="paramname"><em>itLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>relTarget</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns information to identify the middle of the specified path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FIter</td><td>type of iterator to a point in the path </td></tr>
    <tr><td class="paramname">LIter</td><td>type of iterator to a point in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itFirst</td><td>iterator to the first point in the path </td></tr>
    <tr><td class="paramname">itLast</td><td>iterator to the last point in the path (must be valid point) </td></tr>
    <tr><td class="paramname">relTarget</td><td>(default: <code>0.5</code>) fraction of the total length to pursue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>information to identify the desired point</dd></dl>
<p>The sequence between the iterators <code>itFirst</code> and <code>itLast</code>, both included, defines a path. This function returns the point that cuts that path into two subpaths of the same length. The point usually does not match any of the points in the sequence, but rather is in between two of them.</p>
<p>The path is considered a sequence of straight segments connecting the points.</p>
<p>Example of use with a LArSoft <code>recob::Track</code> object (<code>track</code>): </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; path = track.Trajectory().Positions();</div>
<div class="line">geo::Point_t <span class="keyword">const</span> middle</div>
<div class="line">  = util::PathMiddlePoint(path.begin(), std::prev(path.end()));</div>
</div><!-- fragment --><p> (note that here the function actually returns a <code>recob::tracking::Point_t</code>).</p>
<h2>Requirements </h2>
<p>The <code>FIter</code> type is a forward iterator, the type <code>LIter</code> is a backward iterator.</p><ul>
<li><code>FIter</code> must support prefix <code>operator++</code>, <code>LIter</code> must support prefix <code>operator--()</code>.</li>
<li><code>FIter</code> and <code>LIter</code> must compare equal (<code>operator == (FIter, LIter)</code>) if they point to the same element of the sequence.</li>
<li>The two iterators must point to the same type of point (called <code>Point</code> in the following text).</li>
</ul>
<p>The type <code>Point</code> must satisfy the following operations.</p><ul>
<li><code>Vector operator- (Point, Point)</code> returns an object describing the displacement to go from the second point to the first one.</li>
<li><code>geo::vect::norm(Vector)</code> is a function returning the magnitude of the specified displacement vector.</li>
</ul>
<p>LArSoft <code>geo::Point_t</code> type is known to satisfy the requirements of <code>Point</code> (<code>geo::Vector_t</code> being its corresponding <code>Vector</code> type). The modulus function <code>geo::vect::norm()</code> is provided for <code>geo::Vector_t</code> in the LArSoft header <code>larcorealg/CoreUtils/geo_vector_utils.h</code>. </p>

<p class="reference">References <a class="el" href="#adaa9260deeb599367302642a39a3b5b5">util::findCrossingSegment()</a>, <a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath()</a>, <a class="el" href="#a686e20e8e75c4ec003ef382ead5f1c4b">util::partialPathLengths()</a>, <a class="el" href="#aa8facb90d2f47a70dcf14ef46b165646">util::pathLength()</a>, and <a class="el" href="#a9ca0c6bc1f82d56c58d11873336ff0ab">util::pathMiddlePoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath()</a>, and <a class="el" href="#a9ca0c6bc1f82d56c58d11873336ff0ab">util::pathMiddlePoint()</a>.</p>

</div>
</div>
<a id="a686e20e8e75c4ec003ef382ead5f1c4b" name="a686e20e8e75c4ec003ef382ead5f1c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686e20e8e75c4ec003ef382ead5f1c4b">&#9670;&#160;</a></span>partialPathLengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; util::partialPathLengths </td>
          <td>(</td>
          <td class="paramtype">BIter</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sequences of partial lengths for the specified path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the start of the trajectory </td></tr>
    <tr><td class="paramname">EIter</td><td>type of iterator to the end of the trajectory </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to the first point of the trajectory </td></tr>
    <tr><td class="paramname">end</td><td>iterator past the last point of the trajectory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of partial lengths, one per point </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>pathLength()</code></dd></dl>
<p>The sequence of partial lengths is returned, with one entry per point. A partial length up to the point <em>i</em> is the sum of the distances between adjacent points starting from the first point (<code>*begin</code>) to the <em>i</em>-th, included. The first entry of the sequence is always <code>0</code>.</p>
<p>The length are in the same units as the input point coordinates.</p>
<h2>Requirements </h2>
<p>The <code>BIter</code> type is a forward iterator.</p><ul>
<li><code>BIter</code> must support prefix <code>operator++</code></li>
<li><code>operator != (BIter, EIter)</code> must return whether the first iterator is equivalent to the second (or rather, whether the sequence is over).</li>
</ul>
<p>The type <code>Point</code> must satisfy the following operations.</p><ul>
<li><code>Vector operator- (Point, Point)</code> returns an object describing the displacement to go from the second point to the first one.</li>
<li><code>geo::vect::norm(Vector)</code> is a function returning the magnitude of the specified displacement vector. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html#l00437">437</a> of file <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html">TrajectoryUtils.h</a>.</p>

<p class="reference">References <a class="el" href="#a686e20e8e75c4ec003ef382ead5f1c4b">util::partialPathLengths()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath()</a>, and <a class="el" href="#a686e20e8e75c4ec003ef382ead5f1c4b">util::partialPathLengths()</a>.</p>

</div>
</div>
<a id="aa8facb90d2f47a70dcf14ef46b165646" name="aa8facb90d2f47a70dcf14ef46b165646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8facb90d2f47a70dcf14ef46b165646">&#9670;&#160;</a></span>pathLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double util::pathLength </td>
          <td>(</td>
          <td class="paramtype">BIter</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total length of the specified path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the start of the trajectory </td></tr>
    <tr><td class="paramname">EIter</td><td>type of iterator to the end of the trajectory </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to the first point of the trajectory </td></tr>
    <tr><td class="paramname">end</td><td>iterator past the last point of the trajectory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the path </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>partialPathLengths()</code></dd></dl>
<p>The sequence of partial lengths is returned, with one entry per point. The length is the sum of the distances between adjacent points of the sequence. Empty sequences and sequences of a single points have length <code>0</code>.</p>
<p>The length are in the same units as the input point coordinates.</p>
<h2>Requirements </h2>
<p>The <code>BIter</code> type is a forward iterator.</p><ul>
<li><code>BIter</code> must support prefix <code>operator++</code></li>
<li><code>operator != (BIter, EIter)</code> must return whether the first iterator is equivalent to the second (or rather, whether the sequence is over).</li>
</ul>
<p>The type <code>Point</code> must satisfy the following operations.</p><ul>
<li><code>Vector operator- (Point, Point)</code> returns an object describing the displacement to go from the second point to the first one.</li>
<li><code>geo::vect::norm(Vector)</code> is a function returning the magnitude of the specified displacement vector. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html#l00420">420</a> of file <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html">TrajectoryUtils.h</a>.</p>

<p class="reference">References <a class="el" href="#aa8facb90d2f47a70dcf14ef46b165646">util::pathLength()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath()</a>, and <a class="el" href="#aa8facb90d2f47a70dcf14ef46b165646">util::pathLength()</a>.</p>

</div>
</div>
<a id="a9ca0c6bc1f82d56c58d11873336ff0ab" name="a9ca0c6bc1f82d56c58d11873336ff0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca0c6bc1f82d56c58d11873336ff0ab">&#9670;&#160;</a></span>pathMiddlePoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FIter , typename LIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::pathMiddlePoint </td>
          <td>(</td>
          <td class="paramtype">FIter</td>          <td class="paramname"><span class="paramname"><em>itFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LIter</td>          <td class="paramname"><span class="paramname"><em>itLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>relTarget</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometric point in the middle of the specified path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FIter</td><td>type of iterator to a point in the path </td></tr>
    <tr><td class="paramname">LIter</td><td>type of iterator to a point in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itFirst</td><td>iterator to the first point in the path </td></tr>
    <tr><td class="paramname">itLast</td><td>iterator to the last point in the path (must be valid point) </td></tr>
    <tr><td class="paramname">relTarget</td><td>(default: <code>0.5</code>) fraction of the total length to pursue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometric middle point of the path</dd></dl>
<p>The sequence between the iterators <code>itFirst</code> and <code>itLast</code>, both included, defines a path. This function returns the point that cuts that path into two subpaths, the first of which has <code>relTarget</code> fraction of the length of the total path (hence, with the default <code>relTarget</code> value of <code>0.5</code> the two subpaths have the same length). The point usually does not match any of the points in the sequence, but rather is in between two of them.</p>
<p>The path is considered a sequence of straight segments connecting the points.</p>
<p>Example of use with a LArSoft <code>recob::Track</code> object (<code>track</code>): </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; path = track.Trajectory().Positions();</div>
<div class="line">geo::Point_t <span class="keyword">const</span> middle</div>
<div class="line">  = util::PathMiddlePoint(path.begin(), std::prev(path.end()));</div>
</div><!-- fragment --><p> (note that here the function actually returns a <code>recob::tracking::Point_t</code>).</p>
<h2>Requirements </h2>
<p>The <code>FIter</code> type is a forward iterator, the type <code>LIter</code> is a backward iterator.</p><ul>
<li><code>FIter</code> must support prefix <code>operator++</code>, <code>LIter</code> must support prefix <code>operator--()</code>.</li>
<li><code>FIter</code> and <code>LIter</code> must compare equal (<code>operator == (FIter, LIter)</code>) if they point to the same element of the sequence.</li>
<li>The two iterators must point to the same type of point (called <code>Point</code> in the following text).</li>
</ul>
<p>The type <code>Point</code> must satisfy the following operations.</p><ul>
<li><code>Vector operator- (Point, Point)</code> returns an object describing the displacement to go from the second point to the first one.</li>
<li><code>Point operator+ (Point, Vector)</code> returns the point after being displaced by the specified vector.</li>
<li><code>Vector operator* (double)</code> returns a displacement vector with its magnitude rescaled by the specified factor.</li>
<li><code>geo::vect::norm(Vector)</code> is a function returning the magnitude of the specified displacement vector.</li>
</ul>
<p>The returned object is an instance of <code>Point</code>.</p>
<p>LArSoft <code>geo::Point_t</code> type is known to satisfy the requirements of <code>Point</code> (<code>geo::Vector_t</code> being its corresponding <code>Vector</code> type). The modulus function <code>geo::vect::norm()</code> is provided for <code>geo::Vector_t</code> in the LArSoft header <code>larcorealg/CoreUtils/geo_vector_utils.h</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html#l00398">398</a> of file <a class="el" href="../../d6/d02/TrajectoryUtils_8h_source.html">TrajectoryUtils.h</a>.</p>

<p class="reference">References <a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath()</a>, <a class="el" href="../../d6/d01/structutil_1_1PathPointInfo__t.html#abc508bed8c3efbbb26187a28a020ea49">util::PathPointInfo_t&lt; Iter &gt;::frac</a>, <a class="el" href="../../d6/d01/structutil_1_1PathPointInfo__t.html#aefef0669cb952b01562fd33e73383af3">util::PathPointInfo_t&lt; Iter &gt;::itPoint</a>, and <a class="el" href="#a9ca0c6bc1f82d56c58d11873336ff0ab">util::pathMiddlePoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a6632dd48af20f7a5ac4bcea66724fb10">util::findMiddlePointInPath()</a>, and <a class="el" href="#a9ca0c6bc1f82d56c58d11873336ff0ab">util::pathMiddlePoint()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
