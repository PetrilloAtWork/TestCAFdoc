<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAF format: icaruscode/icaruscode/Utilities/DataProductPointerMap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/TeX/AMSmath','[tex]/TeX/AMSsymbols']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','TeX/AMSmath','TeX/AMSsymbols']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CAF format<span id="projectnumber">&#160;${SBNANAOBJ_VERSION}</span>
   </div>
   <div id="projectbrief">Simulation, reconstruction and analysis software for the ICARUS experiment.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3bfe4976819e8434ce603ce37432c4f4.html">icaruscode</a></li><li class="navelem"><a class="el" href="dir_dd542699a33b65b3e6b0c52d22a2f906.html">icaruscode</a></li><li class="navelem"><a class="el" href="dir_da77bb444eb09191e9924c470ade0c3e.html">Utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">DataProductPointerMap.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utilities to map data pointer elements to their <code>art::Ptr</code>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;larcorealg/CoreUtils/enumerate.h&quot;</code><br />
<code>#include &quot;art/Framework/Principal/Event.h&quot;</code><br />
<code>#include &quot;art/Persistency/Common/PtrMaker.h&quot;</code><br />
<code>#include &quot;canvas/Persistency/Common/Ptr.h&quot;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="DataProductPointerMap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a97425dc8a14fa78ee649f9cf9831d703" id="r_a97425dc8a14fa78ee649f9cf9831d703"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97425dc8a14fa78ee649f9cf9831d703"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97425dc8a14fa78ee649f9cf9831d703">util::details::DataProductPointerMap_t</a> = std::map&lt;T const*, art::Ptr&lt;T&gt;&gt;</td></tr>
<tr class="separator:a97425dc8a14fa78ee649f9cf9831d703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cc9c07762cd4890542fa37dd948431" id="r_a86cc9c07762cd4890542fa37dd948431"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:a86cc9c07762cd4890542fa37dd948431"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86cc9c07762cd4890542fa37dd948431">util::ArtHandleData_t</a> = typename Handle::element_type::value_type</td></tr>
<tr class="memdesc:a86cc9c07762cd4890542fa37dd948431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of data in a <em>art</em> handle to vector data product.  <br /></td></tr>
<tr class="separator:a86cc9c07762cd4890542fa37dd948431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cb16bdd814fff09d0419a54a2f2ed8" id="r_a40cb16bdd814fff09d0419a54a2f2ed8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40cb16bdd814fff09d0419a54a2f2ed8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40cb16bdd814fff09d0419a54a2f2ed8">util::DataProductPointerMap_t</a> = details::DataProductPointerMap_t&lt;T&gt;</td></tr>
<tr class="memdesc:a40cb16bdd814fff09d0419a54a2f2ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of map for data product pointers to <em>art</em> pointers.  <br /></td></tr>
<tr class="separator:a40cb16bdd814fff09d0419a54a2f2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4077892651ee6d757c45def0b06f7f9d" id="r_a4077892651ee6d757c45def0b06f7f9d"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:a4077892651ee6d757c45def0b06f7f9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a40cb16bdd814fff09d0419a54a2f2ed8">DataProductPointerMap_t</a>&lt; <a class="el" href="#a86cc9c07762cd4890542fa37dd948431">ArtHandleData_t</a>&lt; Handle &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4077892651ee6d757c45def0b06f7f9d">util::mapDataProductPointers</a> (art::Event const &amp;event, Handle const &amp;handle)</td></tr>
<tr class="memdesc:a4077892651ee6d757c45def0b06f7f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a map from address of data product element to <em>art</em> pointer to it.  <br /></td></tr>
<tr class="separator:a4077892651ee6d757c45def0b06f7f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utilities to map data pointer elements to their <code>art::Ptr</code>. </p>
<dl class="section author"><dt>Author</dt><dd>Gianluca Petrillo (<a href="mailto:petrillo@slac.stanford.edu">petrillo@slac.stanford.edu</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>December 13, 2019</dd></dl>
<p>This library is header only. </p>

<p class="definition">Definition in file <a class="el" href="DataProductPointerMap_8h_source.html">DataProductPointerMap.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a86cc9c07762cd4890542fa37dd948431" name="a86cc9c07762cd4890542fa37dd948431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cc9c07762cd4890542fa37dd948431">&#9670;&#160;</a></span>ArtHandleData_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a86cc9c07762cd4890542fa37dd948431">util::ArtHandleData_t</a> = typename Handle::element_type::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of data in a <em>art</em> handle to vector data product. </p>

<p class="definition">Definition at line <a class="el" href="DataProductPointerMap_8h_source.html#l00042">42</a> of file <a class="el" href="DataProductPointerMap_8h_source.html">DataProductPointerMap.h</a>.</p>

</div>
</div>
<a id="a40cb16bdd814fff09d0419a54a2f2ed8" name="a40cb16bdd814fff09d0419a54a2f2ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cb16bdd814fff09d0419a54a2f2ed8">&#9670;&#160;</a></span>DataProductPointerMap_t <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a40cb16bdd814fff09d0419a54a2f2ed8">util::DataProductPointerMap_t</a> = details::DataProductPointerMap_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of map for data product pointers to <em>art</em> pointers. </p>

<p class="definition">Definition at line <a class="el" href="DataProductPointerMap_8h_source.html#l00046">46</a> of file <a class="el" href="DataProductPointerMap_8h_source.html">DataProductPointerMap.h</a>.</p>

</div>
</div>
<a id="a97425dc8a14fa78ee649f9cf9831d703" name="a97425dc8a14fa78ee649f9cf9831d703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97425dc8a14fa78ee649f9cf9831d703">&#9670;&#160;</a></span>DataProductPointerMap_t <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using util::details::DataProductPointerMap_t = std::map&lt;T const*, art::Ptr&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataProductPointerMap_8h_source.html#l00035">35</a> of file <a class="el" href="DataProductPointerMap_8h_source.html">DataProductPointerMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4077892651ee6d757c45def0b06f7f9d" name="a4077892651ee6d757c45def0b06f7f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4077892651ee6d757c45def0b06f7f9d">&#9670;&#160;</a></span>mapDataProductPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DataProductPointerMap_t&lt; ArtHandleData_t&lt; Handle &gt; &gt; util::mapDataProductPointers </td>
          <td>(</td>
          <td class="paramtype">art::Event const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle const &amp;</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a map from address of data product element to <em>art</em> pointer to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle</td><td>type of handle to data product (e.g. <code>art::ValidHandle</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><em>art</em> handle to the data product </td></tr>
    <tr><td class="paramname">event</td><td>the <em>art</em> event the data product belongs to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map from data product element pointer to <em>art</em> pointer</dd></dl>
<p>Returns a map from the address of any of the objects in the data product in <code>event</code> pointed by <code>handle</code> and the <em>art</em> pointer to those objects. Provided that the type in the data product is <code>T</code>, the returned map is an object guaranteed to have:</p><ul>
<li>standard mobility (copy and move constructors and assignment operators)</li>
<li>an unckecked access operator <code>operator[] (T const*) const</code> returning some form of <code>art::Ptr&lt;T&gt;</code> (<code>art::Ptr&lt;T&gt;</code>, <code>art::Ptr&lt;T&gt; const&amp;</code>...);</li>
<li>a checked access operator <code>at(T const*) const</code> similar to <code>operator[]</code> but throwing an exception derived from <code>std::out_of_range</code> if the element is not found;</li>
<li>an <code>empty()</code>, a <code>size()</code> and a <code>clear()</code> method.</li>
</ul>
<p>Example: with <code>event</code> a <code>art::Event</code> object and <code>waveformHandle</code> an handle to a <code>std::vector&lt;raw::OpDetWaveform&gt;</code> data product in <code>event</code>: </p><div class="fragment"><div class="line">DataProductPointerMap_t&lt;raw::OpDetWaveform&gt; <span class="keyword">const</span>&amp; opDetWavePtrs</div>
<div class="line">  = util::mapDataProductPointers(event, waveformHandle);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (raw::OpDetWaveform <span class="keyword">const</span>&amp; waveform: *waveformHandle) {</div>
<div class="line"> </div>
<div class="line">  art::Ptr&lt;raw::OpDetWaveform&gt; <span class="keyword">const</span>&amp; ptr = opDetWavePtrs.at(&amp;waveform);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> in the loop the <code>art::Ptr</code> of each <code>waveform</code> is tracked without carrying around the index of the waveform in the original data product.</p>
<p>There are alternative approaches to this: one can rely on the contiguous memory model of <code>std::vector</code> and carry around the address of the first waveform, <code>&amp;(waveformHandle-&gt;front())</code>, and a properly initialized <code>art::PtrMaker</code> which can then invoked as <code>ptrMaker(&amp;waveform - waveform0ptr)</code>; or work directly with <code>art::Ptr</code>. This approach is more factorised than the first alternative (knowledge of the event is not required any more during the iteration) and arguably faster than the second, where <em>art</em> pointer dereferencing always has a small overhead, but it uses more memory.</p>
<dl class="section note"><dt>Note</dt><dd>The returned object is currently a C++ STL data container. Optimizations are possible using a different data structure (for example, a vector-based container with index based on the difference described in the example above) and they may in future be implemented. Because of this reason, it is recommended that the produced map is stored in variables declared with an <code>auto const&amp;</code> type or as a <code>DataProductPointerMap_t</code> instance, rather than with the currently underlying data type. </dd></dl>

<p class="reference">References <a class="el" href="#a4077892651ee6d757c45def0b06f7f9d">util::mapDataProductPointers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a4077892651ee6d757c45def0b06f7f9d">util::mapDataProductPointers()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
